[
  {
    "Name": "OpNop",
    "Description": "<a id=\"OpNop\"></a><strong>OpNop</strong><br />\n<br />\n This has no semantic impact and can safely be removed from a module.",
    "DescriptionPlain": "OpNop\n\n This has no semantic impact and can safely be removed from a module.",
    "Category": "Miscellaneous",
    "Capabilities": [],
    "WordCount": "1",
    "WordCountFix": 1,
    "OpCode": 0,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": []
  },
  {
    "Name": "OpUndef",
    "Description": "<a id=\"OpUndef\"></a><strong>OpUndef</strong><br />\n<br />\nMake an <a href=\"#Intermediate\">intermediate</a> object whose value is undefined.<br />\n<br />\n<em>Result Type</em> is the type of object to make.<br />\n<br />\nEach consumption of <em>Result &lt;id&gt;</em> yields an arbitrary, possibly different bit pattern.",
    "DescriptionPlain": "OpUndef\n\nMake an intermediate object whose value is undefined.\n\nResult Type is the type of object to make.\n\nEach consumption of Result &lt;id&gt; yields an arbitrary, possibly different bit pattern.",
    "Category": "Miscellaneous",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 1,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSizeOf",
    "Description": "<a id=\"OpSizeOf\"></a><strong>OpSizeOf</strong><br />\n<br />\nComputes the run-time size of the type pointed to by <em>Pointer</em><br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pointer</em> must point to a concrete type.",
    "DescriptionPlain": "OpSizeOf\n\nComputes the run-time size of the type pointed to by Pointer\n\nResult Type must be a 32-bit integer type scalar.\n\nPointer must point to a concrete type.",
    "Category": "Miscellaneous",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 321,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSourceContinued",
    "Description": "<a id=\"OpSourceContinued\"></a><strong>OpSourceContinued</strong><br />\n<br />\nContinue specifying the <em>Source</em> text from the previous instruction. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Continued Source</em> is a continuation of the source text in the previous <em>Source</em>.<br />\n<br />\nThe previous instruction must be an <a href=\"#OpSource\"><strong>OpSource</strong></a> or an <strong>OpSourceContinued</strong> instruction. As is true for all literal strings, the previous instruction&#8217;s string was nul terminated. That terminating 0 word from the previous instruction is not part of the source text; the first character of <em>Continued Source</em> logically immediately follows the last character of <em>Source</em> before its nul.",
    "DescriptionPlain": "OpSourceContinued\n\nContinue specifying the Source text from the previous instruction. This has no semantic impact and can safely be removed from a module.\n\nContinued Source is a continuation of the source text in the previous Source.\n\nThe previous instruction must be an OpSource or an OpSourceContinued instruction. As is true for all literal strings, the previous instruction&#8217;s string was nul terminated. That terminating 0 word from the previous instruction is not part of the source text; the first character of Continued Source logically immediately follows the last character of Source before its nul.",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "2 + variable",
    "WordCountFix": 2,
    "OpCode": 2,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "ContinuedSource",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpSource",
    "Description": "<a id=\"OpSource\"></a><strong>OpSource</strong><br />\n<br />\nDocument what <a href=\"#Source_Language\">source language</a> and text this module was translated from. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Version</em> is the version of the source language. This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<br />\n<em>File</em> is an <a href=\"#OpString\"><strong>OpString</strong></a> instruction and is the source-level file name.<br />\n<br />\n<em>Source</em> is the text of the source-level file.<br />\n<br />\nEach client API describes what form the <em>Version</em> operand takes, per source language.",
    "DescriptionPlain": "OpSource\n\nDocument what source language and text this module was translated from. This has no semantic impact and can safely be removed from a module.\n\nVersion is the version of the source language. This literal operand is limited to a single word.\n\nFile is an OpString instruction and is the source-level file name.\n\nSource is the text of the source-level file.\n\nEach client API describes what form the Version operand takes, per source language.",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 3,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "SourceLanguage",
        "Type": "SourceLanguage"
      },
      {
        "Name": "Version",
        "Type": "LiteralNumber"
      },
      {
        "Name": "File",
        "Type": "ID?"
      },
      {
        "Name": "StringSource",
        "Type": "OptionalLiteral"
      }
    ]
  },
  {
    "Name": "OpSourceExtension",
    "Description": "<a id=\"OpSourceExtension\"></a><strong>OpSourceExtension</strong><br />\n<br />\nDocument an extension to the source language. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Extension</em> is a string describing a source-language extension. Its form is dependent on the how the source language describes extensions.",
    "DescriptionPlain": "OpSourceExtension\n\nDocument an extension to the source language. This has no semantic impact and can safely be removed from a module.\n\nExtension is a string describing a source-language extension. Its form is dependent on the how the source language describes extensions.",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "2 + variable",
    "WordCountFix": 2,
    "OpCode": 4,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Extension",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpName",
    "Description": "<a id=\"OpName\"></a><strong>OpName</strong><br />\n<br />\nAssign a name string to another instruction&#8217;s <em>Result &lt;id&gt;</em>. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Target</em> is the <em>Result &lt;id&gt;</em> to assign a name to. It can be the <em>Result &lt;id&gt;</em> of any other instruction; a variable, function, type, intermediate result, etc.<br />\n<br />\n<em>Name</em> is the string to assign.",
    "DescriptionPlain": "OpName\n\nAssign a name string to another instruction&#8217;s Result &lt;id&gt;. This has no semantic impact and can safely be removed from a module.\n\nTarget is the Result &lt;id&gt; to assign a name to. It can be the Result &lt;id&gt; of any other instruction; a variable, function, type, intermediate result, etc.\n\nName is the string to assign.",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 5,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Target",
        "Type": "ID"
      },
      {
        "Name": "Name",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpMemberName",
    "Description": "<a id=\"OpMemberName\"></a><strong>OpMemberName</strong><br />\n<br />\nAssign a name string to a member of a structure type. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Type</em> is the <em>&lt;id&gt;</em> from an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> instruction.<br />\n<br />\n<em>Member</em> is the number of the member to assign in the structure. The first member is member 0, the next is member 1, &#8230; This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<br />\n<em>Name</em> is the string to assign to the member.",
    "DescriptionPlain": "OpMemberName\n\nAssign a name string to a member of a structure type. This has no semantic impact and can safely be removed from a module.\n\nType is the &lt;id&gt; from an OpTypeStruct instruction.\n\nMember is the number of the member to assign in the structure. The first member is member 0, the next is member 1, &#8230; This literal operand is limited to a single word.\n\nName is the string to assign to the member.",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 6,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Type",
        "Type": "ID"
      },
      {
        "Name": "Member",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Name",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpString",
    "Description": "<a id=\"OpString\"></a><strong>OpString</strong><br />\n<br />\nAssign a <em>Result &lt;id&gt;</em> to a string for use by other debug instructions (see <a href=\"#OpLine\"><strong>OpLine</strong></a> and <a href=\"#OpSource\"><strong>OpSource</strong></a>). This has no semantic impact and can safely be removed from a module. (Removal also requires removal of all instructions referencing <em>Result &lt;id&gt;</em>.)<br />\n<br />\n<em>String</em> is the literal string being assigned a <em>Result &lt;id&gt;</em>.",
    "DescriptionPlain": "OpString\n\nAssign a Result &lt;id&gt; to a string for use by other debug instructions (see OpLine and OpSource). This has no semantic impact and can safely be removed from a module. (Removal also requires removal of all instructions referencing Result &lt;id&gt;.)\n\nString is the literal string being assigned a Result &lt;id&gt;.",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 7,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "String",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpLine",
    "Description": "<a id=\"OpLine\"></a><strong>OpLine</strong><br />\n<br />\nAdd source-level location information. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n This location information applies to the instructions physically following this instruction, up to the first occurrence of any of the following: the next end of block, the next <strong>OpLine</strong> instruction, or the next <a href=\"#OpNoLine\"><strong>OpNoLine</strong></a> instruction.<br />\n<br />\n<em>File</em> must be an <a href=\"#OpString\"><strong>OpString</strong></a> instruction and is the source-level file name.<br />\n<br />\n<em>Line</em> is the source-level line number. This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<br />\n<em>Column</em> is the source-level column number. This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<br />\n<strong>OpLine</strong> can generally immediately precede other instructions, with the following exceptions:<br />\n<br />\n - it may not be used until after the <a href=\"#Annotation\">annotation</a> instructions,<br />\n   (see the <a href=\"#LogicalLayout\">Logical Layout</a> section)<br />\n<br />\n - cannot be the last instruction in a block, which is defined to end with a <a href=\"#Termination\">termination instruction</a><br />\n<br />\n - if a branch <a href=\"#Merge\">merge instruction</a> is used, the last <strong>OpLine</strong> in the block must be before its merge instruction",
    "DescriptionPlain": "OpLine\n\nAdd source-level location information. This has no semantic impact and can safely be removed from a module.\n\n This location information applies to the instructions physically following this instruction, up to the first occurrence of any of the following: the next end of block, the next OpLine instruction, or the next OpNoLine instruction.\n\nFile must be an OpString instruction and is the source-level file name.\n\nLine is the source-level line number. This literal operand is limited to a single word.\n\nColumn is the source-level column number. This literal operand is limited to a single word.\n\nOpLine can generally immediately precede other instructions, with the following exceptions:\n\n - it may not be used until after the annotation instructions,\n   (see the Logical Layout section)\n\n - cannot be the last instruction in a block, which is defined to end with a termination instruction\n\n - if a branch merge instruction is used, the last OpLine in the block must be before its merge instruction",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 8,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "File",
        "Type": "ID"
      },
      {
        "Name": "Line",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Column",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpNoLine",
    "Description": "<a id=\"OpNoLine\"></a><strong>OpNoLine</strong><br />\n<br />\nDiscontinue any source-level location information that might be active from a previous <a href=\"#OpLine\"><strong>OpLine</strong></a> instruction. This has no semantic impact and can safely be removed from a module.<br />\n<br />\nThis instruction can only appear after the <a href=\"#Annotation\">annotation</a> instructions (see the <a href=\"#LogicalLayout\">Logical Layout</a> section). It cannot be the last instruction in a block, or the second-to-last instruction if the block has a <a href=\"#Merge\">merge instruction</a>. There is not a requirement that there is a preceding <strong>OpLine</strong> instruction.",
    "DescriptionPlain": "OpNoLine\n\nDiscontinue any source-level location information that might be active from a previous OpLine instruction. This has no semantic impact and can safely be removed from a module.\n\nThis instruction can only appear after the annotation instructions (see the Logical Layout section). It cannot be the last instruction in a block, or the second-to-last instruction if the block has a merge instruction. There is not a requirement that there is a preceding OpLine instruction.",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "1",
    "WordCountFix": 1,
    "OpCode": 317,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": []
  },
  {
    "Name": "OpModuleProcessed",
    "Description": "<a id=\"OpModuleProcessed\"></a><strong>OpModuleProcessed</strong><br />\n<br />\nDocument a process that was applied to a module. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Process</em> is a string describing a process and/or tool (processor) that did the processing. Its form is dependent on the processor.",
    "DescriptionPlain": "OpModuleProcessed\n\nDocument a process that was applied to a module. This has no semantic impact and can safely be removed from a module.\n\nProcess is a string describing a process and/or tool (processor) that did the processing. Its form is dependent on the processor.",
    "Category": "Debug",
    "Capabilities": [],
    "WordCount": "2 + variable",
    "WordCountFix": 2,
    "OpCode": 330,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Process",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpDecorate",
    "Description": "<a id=\"OpDecorate\"></a><strong>OpDecorate</strong><br />\n<br />\nAdd a <a href=\"#Decoration\">Decoration</a> to another <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Target</em> is the <em>&lt;id&gt;</em> to decorate.  It can potentially be any <em>&lt;id&gt;</em> that is a forward reference. A set of decorations can be grouped together by having multiple <strong>OpDecorate</strong> instructions target the same <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.",
    "DescriptionPlain": "OpDecorate\n\nAdd a Decoration to another &lt;id&gt;.\n\nTarget is the &lt;id&gt; to decorate.  It can potentially be any &lt;id&gt; that is a forward reference. A set of decorations can be grouped together by having multiple OpDecorate instructions target the same OpDecorationGroup instruction.",
    "Category": "Annotation",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 71,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Target",
        "Type": "ID"
      },
      {
        "Name": "Decoration",
        "Type": "Decoration"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpMemberDecorate",
    "Description": "<a id=\"OpMemberDecorate\"></a><strong>OpMemberDecorate</strong><br />\n<br />\nAdd a <a href=\"#Decoration\">Decoration</a> to a member of a structure type.<br />\n<br />\n<em>Structure type</em> is the <em>&lt;id&gt;</em> of a type from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.<br />\n<br />\n<em>Member</em> is the number of the member to decorate in the type. The first member is member 0, the next is member 1, &#8230;<br />\n<br />\nNote: See <strong>OpDecorate</strong> for creating groups of decorations for consumption by <strong>OpGroupMemberDecorate</strong>",
    "DescriptionPlain": "OpMemberDecorate\n\nAdd a Decoration to a member of a structure type.\n\nStructure type is the &lt;id&gt; of a type from OpTypeStruct.\n\nMember is the number of the member to decorate in the type. The first member is member 0, the next is member 1, &#8230;\n\nNote: See OpDecorate for creating groups of decorations for consumption by OpGroupMemberDecorate",
    "Category": "Annotation",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 72,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "StructureType",
        "Type": "ID"
      },
      {
        "Name": "Member",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Decoration",
        "Type": "Decoration"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpDecorationGroup",
    "Description": "<a id=\"OpDecorationGroup\"></a><strong>OpDecorationGroup</strong><br />\n<br />\nA collector for <a href=\"#Decoration\">Decorations</a> from <a href=\"#OpDecorate\"><strong>OpDecorate</strong></a> instructions. All such <strong>OpDecorate</strong> instructions targeting this <strong>OpDecorationGroup</strong> instruction must precede it. Subsequent <a href=\"#OpGroupDecorate\"><strong>OpGroupDecorate</strong></a> and <a href=\"#OpGroupMemberDecorate\"><strong>OpGroupMemberDecorate</strong></a> instructions that consume this instruction&#8217;s <em>Result &lt;id&gt;</em> will apply these decorations to their targets.",
    "DescriptionPlain": "OpDecorationGroup\n\nA collector for Decorations from OpDecorate instructions. All such OpDecorate instructions targeting this OpDecorationGroup instruction must precede it. Subsequent OpGroupDecorate and OpGroupMemberDecorate instructions that consume this instruction&#8217;s Result &lt;id&gt; will apply these decorations to their targets.",
    "Category": "Annotation",
    "Capabilities": [],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 73,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupDecorate",
    "Description": "<a id=\"OpGroupDecorate\"></a><strong>OpGroupDecorate</strong><br />\n<br />\nAdd a group of <a href=\"#Decoration\">Decorations</a> to another <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Decoration Group</em> is the <em>&lt;id&gt;</em> of an <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.<br />\n<br />\n<em>Targets</em> is a list of <em>&lt;id&gt;s</em> to decorate with the groups of decorations.",
    "DescriptionPlain": "OpGroupDecorate\n\nAdd a group of Decorations to another &lt;id&gt;.\n\nDecoration Group is the &lt;id&gt; of an OpDecorationGroup instruction.\n\nTargets is a list of &lt;id&gt;s to decorate with the groups of decorations.",
    "Category": "Annotation",
    "Capabilities": [],
    "WordCount": "2 + variable",
    "WordCountFix": 2,
    "OpCode": 74,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "DecorationGroup",
        "Type": "ID"
      },
      {
        "Name": "Targets",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpGroupMemberDecorate",
    "Description": "<a id=\"OpGroupMemberDecorate\"></a><strong>OpGroupMemberDecorate</strong><br />\n<br />\nAdd a group of <a href=\"#Decoration\">Decorations</a> to members of structure types.<br />\n<br />\n<em>Decoration Group</em> is the <em>&lt;id&gt;</em> of an <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.<br />\n<br />\n<em>Targets</em> is a list of (<em>&lt;id&gt;</em>, <em>Member</em>) pairs to decorate with the groups of decorations. Each <em>&lt;id&gt;</em> in the pair must be a target structure type, and the associated <em>Member</em> is the number of the member to decorate in the type. The first member is member 0, the next is member 1, &#8230;",
    "DescriptionPlain": "OpGroupMemberDecorate\n\nAdd a group of Decorations to members of structure types.\n\nDecoration Group is the &lt;id&gt; of an OpDecorationGroup instruction.\n\nTargets is a list of (&lt;id&gt;, Member) pairs to decorate with the groups of decorations. Each &lt;id&gt; in the pair must be a target structure type, and the associated Member is the number of the member to decorate in the type. The first member is member 0, the next is member 1, &#8230;",
    "Category": "Annotation",
    "Capabilities": [],
    "WordCount": "2 + variable",
    "WordCountFix": 2,
    "OpCode": 75,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "DecorationGroup",
        "Type": "ID"
      },
      {
        "Name": "<id>s",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpExtension",
    "Description": "<a id=\"OpExtension\"></a><strong>OpExtension</strong><br />\n<br />\nDeclare use of an extension to SPIR-V. This allows validation of additional instructions, tokens, semantics, etc.<br />\n<br />\n<em>Name</em> is the extension&#8217;s name string.",
    "DescriptionPlain": "OpExtension\n\nDeclare use of an extension to SPIR-V. This allows validation of additional instructions, tokens, semantics, etc.\n\nName is the extension&#8217;s name string.",
    "Category": "Extension",
    "Capabilities": [],
    "WordCount": "2 + variable",
    "WordCountFix": 2,
    "OpCode": 10,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Name",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpExtInstImport",
    "Description": "<a id=\"OpExtInstImport\"></a><strong>OpExtInstImport</strong><br />\n<br />\nImport an extended set of instructions. It can be later referenced by the <em>Result &lt;id&gt;</em>.<br />\n<br />\n<em>Name</em> is the extended instruction-set&#8217;s name string. There must be an external specification defining the semantics for this extended instruction set.<br />\n<br />\nSee <a href=\"#ExtInst\">Extended Instruction Sets</a> for more information.",
    "DescriptionPlain": "OpExtInstImport\n\nImport an extended set of instructions. It can be later referenced by the Result &lt;id&gt;.\n\nName is the extended instruction-set&#8217;s name string. There must be an external specification defining the semantics for this extended instruction set.\n\nSee Extended Instruction Sets for more information.",
    "Category": "Extension",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 11,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Name",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpExtInst",
    "Description": "<a id=\"OpExtInst\"></a><strong>OpExtInst</strong><br />\n<br />\nExecute an instruction in an imported set of extended instructions.<br />\n<br />\n<em>Result Type</em> is as defined, per <em>Instruction</em>, in the external specification for <em>Set</em>.<br />\n<br />\n<em>Set</em> is the result of an <a href=\"#OpExtInstImport\"><strong>OpExtInstImport</strong></a> instruction.<br />\n<br />\n<em>Instruction</em> is the enumerant of the instruction to execute within <em>Set</em>. This literal operand is limited to a single <a href=\"#Word\">word</a>. The semantics of the instruction must be defined in the external specification for <em>Set</em>.<br />\n<br />\n<em>Operand 1, &#8230;</em> are the operands to the extended instruction.",
    "DescriptionPlain": "OpExtInst\n\nExecute an instruction in an imported set of extended instructions.\n\nResult Type is as defined, per Instruction, in the external specification for Set.\n\nSet is the result of an OpExtInstImport instruction.\n\nInstruction is the enumerant of the instruction to execute within Set. This literal operand is limited to a single word. The semantics of the instruction must be defined in the external specification for Set.\n\nOperand 1, &#8230; are the operands to the extended instruction.",
    "Category": "Extension",
    "Capabilities": [],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 12,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Set",
        "Type": "ID"
      },
      {
        "Name": "Instruction",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Operands",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpMemoryModel",
    "Description": "<a id=\"OpMemoryModel\"></a><strong>OpMemoryModel</strong><br />\n<br />\nSet addressing model and memory model for the entire module.<br />\n<br />\n<em>Addressing Model</em> selects the module&#8217;s <a href=\"#Addressing_Model\"><strong>Addressing Model</strong></a>.<br />\n<br />\n<em>Memory Model</em> selects the module&#8217;s memory model, see <a href=\"#Memory_Model\"><strong>Memory Model</strong></a>.",
    "DescriptionPlain": "OpMemoryModel\n\nSet addressing model and memory model for the entire module.\n\nAddressing Model selects the module&#8217;s Addressing Model.\n\nMemory Model selects the module&#8217;s memory model, see Memory Model.",
    "Category": "Mode-Setting",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 14,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "AddressingModel",
        "Type": "AddressingModel"
      },
      {
        "Name": "MemoryModel",
        "Type": "MemoryModel"
      }
    ]
  },
  {
    "Name": "OpEntryPoint",
    "Description": "<a id=\"OpEntryPoint\"></a><strong>OpEntryPoint</strong><br />\n<br />\nDeclare an <a href=\"#EntryPoint\">entry point</a> and its execution model.<br />\n<br />\n<em>Execution Model</em> is the execution model for the entry point and its static call tree.  See <a href=\"#Execution_Model\">Execution Model</a>.<br />\n<br />\n<em>Entry Point</em> must be the <em>Result &lt;id&gt;</em> of an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.<br />\n<br />\n<em>Name</em> is a name string for the entry point. A module cannot have two <strong>OpEntryPoint</strong> instructions with the same <a href=\"#Execution_Model\">Execution Model</a> and the same <em>Name</em> string.<br />\n<br />\n<em>Interface</em> is a list of <em>&lt;id&gt;</em> of global <a href=\"#OpVariable\"><strong>OpVariable</strong></a> instructions with either <strong>Input</strong> or <strong>Output</strong> for its <a href=\"#Storage_Class\">Storage Class</a> operand. These declare the input/output interface of the entry point.  They could be a subset of the input/output declarations of the module, and a superset of those referenced by the entry point&#8217;s static call tree. It is invalid for the entry point&#8217;s static call tree to reference such an <em>&lt;id&gt;</em> if it was not listed with this instruction.<br />\n<br />\n<em>Interface</em> <em>&lt;id&gt;</em> are forward references.  They allow declaration of all variables forming an interface for an entry point, whether or not all the variables are actually used by the entry point.",
    "DescriptionPlain": "OpEntryPoint\n\nDeclare an entry point and its execution model.\n\nExecution Model is the execution model for the entry point and its static call tree.  See Execution Model.\n\nEntry Point must be the Result &lt;id&gt; of an OpFunction instruction.\n\nName is a name string for the entry point. A module cannot have two OpEntryPoint instructions with the same Execution Model and the same Name string.\n\nInterface is a list of &lt;id&gt; of global OpVariable instructions with either Input or Output for its Storage Class operand. These declare the input/output interface of the entry point.  They could be a subset of the input/output declarations of the module, and a superset of those referenced by the entry point&#8217;s static call tree. It is invalid for the entry point&#8217;s static call tree to reference such an &lt;id&gt; if it was not listed with this instruction.\n\nInterface &lt;id&gt; are forward references.  They allow declaration of all variables forming an interface for an entry point, whether or not all the variables are actually used by the entry point.",
    "Category": "Mode-Setting",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 15,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "ExecutionModel",
        "Type": "ExecutionModel"
      },
      {
        "Name": "EntryPoint",
        "Type": "ID"
      },
      {
        "Name": "Name",
        "Type": "LiteralString"
      },
      {
        "Name": "Interfaces",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpExecutionMode",
    "Description": "<a id=\"OpExecutionMode\"></a><strong>OpExecutionMode</strong><br />\n<br />\nDeclare an execution mode for an entry point.<br />\n<br />\n<em>Entry Point</em> must be the <em>Entry Point &lt;id&gt;</em> operand of an <a href=\"#OpEntryPoint\"><strong>OpEntryPoint</strong></a> instruction.<br />\n<br />\n<em>Mode</em> is the execution mode. See <a href=\"#Execution_Mode\">Execution Mode</a>.",
    "DescriptionPlain": "OpExecutionMode\n\nDeclare an execution mode for an entry point.\n\nEntry Point must be the Entry Point &lt;id&gt; operand of an OpEntryPoint instruction.\n\nMode is the execution mode. See Execution Mode.",
    "Category": "Mode-Setting",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 16,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "EntryPoint",
        "Type": "ID"
      },
      {
        "Name": "Mode",
        "Type": "ExecutionMode"
      },
      {
        "Name": "SeeExecutionMode",
        "Type": "OptionalLiteral(s)"
      }
    ]
  },
  {
    "Name": "OpCapability",
    "Description": "<a id=\"OpCapability\"></a><strong>OpCapability</strong><br />\n<br />\nDeclare a capability used by this module.<br />\n<br />\n<em>Capability</em> is the <a href=\"#Capability\">capability</a> declared by this instruction.  There are no restrictions on the order in which capabilities are declared.<br />\n<br />\nSee the <a href=\"#Capabilities\">capabilities section</a> for more detail.",
    "DescriptionPlain": "OpCapability\n\nDeclare a capability used by this module.\n\nCapability is the capability declared by this instruction.  There are no restrictions on the order in which capabilities are declared.\n\nSee the capabilities section for more detail.",
    "Category": "Mode-Setting",
    "Capabilities": [],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 17,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "<null>",
        "Type": "<null>"
      }
    ]
  },
  {
    "Name": "OpTypeVoid",
    "Description": "<a id=\"OpTypeVoid\"></a><strong>OpTypeVoid</strong><br />\n<br />\nDeclare the void type.",
    "DescriptionPlain": "OpTypeVoid\n\nDeclare the void type.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 19,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeBool",
    "Description": "<a id=\"OpTypeBool\"></a><strong>OpTypeBool</strong><br />\n<br />\nDeclare the <a href=\"#Boolean\"><em>Boolean type</em></a>.  Values of this type can only be either <strong>true</strong> or <strong>false</strong>. There is no physical size or bit pattern defined for these values.  If they are stored (in conjunction with <a href=\"#OpVariable\"><strong>OpVariable</strong></a>), they can only be used with logical addressing operations, not physical, and only with non-externally visible shader <a href=\"#Storage_Class\">Storage Classes</a>: <strong>Workgroup</strong>, <strong>CrossWorkgroup</strong>, <strong>Private</strong>, and <strong>Function</strong>.",
    "DescriptionPlain": "OpTypeBool\n\nDeclare the Boolean type.  Values of this type can only be either true or false. There is no physical size or bit pattern defined for these values.  If they are stored (in conjunction with OpVariable), they can only be used with logical addressing operations, not physical, and only with non-externally visible shader Storage Classes: Workgroup, CrossWorkgroup, Private, and Function.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 20,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeInt",
    "Description": "<a id=\"OpTypeInt\"></a><strong>OpTypeInt</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>integer type</em></a>.<br />\n<br />\n<em>Width</em> specifies how many bits wide the type is. This literal operand is limited to a single <a href=\"#Word\">word</a>. The bit pattern of a signed integer value is two&#8217;s complement.<br />\n<br />\n<em>Signedness</em> specifies whether there are signed semantics to preserve or validate.<br />\n0 indicates unsigned, or no signedness semantics<br />\n1 indicates signed semantics.<br />\nIn all cases, the type of operation of an instruction comes from the instruction&#8217;s opcode, not the signedness of the operands.",
    "DescriptionPlain": "OpTypeInt\n\nDeclare a new integer type.\n\nWidth specifies how many bits wide the type is. This literal operand is limited to a single word. The bit pattern of a signed integer value is two&#8217;s complement.\n\nSignedness specifies whether there are signed semantics to preserve or validate.\n0 indicates unsigned, or no signedness semantics\n1 indicates signed semantics.\nIn all cases, the type of operation of an instruction comes from the instruction&#8217;s opcode, not the signedness of the operands.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 21,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Width",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Signedness",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpTypeFloat",
    "Description": "<a id=\"OpTypeFloat\"></a><strong>OpTypeFloat</strong><br />\n<br />\nDeclare a new <a href=\"#Floating\"><em>floating-point type</em></a>.<br />\n<br />\n<em>Width</em> specifies how many bits wide the type is. The bit pattern of a floating-point value is as described by the IEEE 754 standard.",
    "DescriptionPlain": "OpTypeFloat\n\nDeclare a new floating-point type.\n\nWidth specifies how many bits wide the type is. The bit pattern of a floating-point value is as described by the IEEE 754 standard.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 22,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Width",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpTypeVector",
    "Description": "<a id=\"OpTypeVector\"></a><strong>OpTypeVector</strong><br />\n<br />\nDeclare a new <a href=\"#Vector\">vector type</a>.<br />\n<br />\n<em>Component Type</em> is the type of each component in the resulting type.  It must be a <a href=\"#Scalar\">scalar type</a>.<br />\n<br />\n<em>Component Count</em> is the number of components in the resulting type.  It must be at least 2.<br />\n<br />\nComponents are numbered consecutively, starting with 0.",
    "DescriptionPlain": "OpTypeVector\n\nDeclare a new vector type.\n\nComponent Type is the type of each component in the resulting type.  It must be a scalar type.\n\nComponent Count is the number of components in the resulting type.  It must be at least 2.\n\nComponents are numbered consecutively, starting with 0.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 23,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ComponentType",
        "Type": "ID"
      },
      {
        "Name": "ComponentCount",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpTypeMatrix",
    "Description": "<a id=\"OpTypeMatrix\"></a><strong>OpTypeMatrix</strong><br />\n<br />\nDeclare a new matrix type.<br />\n<br />\n<em>Column Type</em> is the type of each column in the matrix.  It must be vector type.<br />\n<br />\n<em>Column Count</em> is the number of columns in the new matrix type. It must be at least 2.<br />\n<br />\nMatrix columns are numbered consecutively, starting with 0. This is true independently of any <a href=\"#Decoration\">Decorations</a> describing the memory layout of a matrix (e.g., <strong>RowMajor</strong> or <strong>MatrixStride</strong>).",
    "DescriptionPlain": "OpTypeMatrix\n\nDeclare a new matrix type.\n\nColumn Type is the type of each column in the matrix.  It must be vector type.\n\nColumn Count is the number of columns in the new matrix type. It must be at least 2.\n\nMatrix columns are numbered consecutively, starting with 0. This is true independently of any Decorations describing the memory layout of a matrix (e.g., RowMajor or MatrixStride).",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 24,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ColumnType",
        "Type": "ID"
      },
      {
        "Name": "ColumnCount",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpTypeImage",
    "Description": "<a id=\"OpTypeImage\"></a><strong>OpTypeImage</strong><br />\n<br />\nDeclare a new <a href=\"#ImageTerm\">image</a> type. Consumed, for example, by <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. This type is opaque: values of this type have no defined physical size or bit pattern.<br />\n<br />\n<em>Sampled Type</em> is the type of the components that result from sampling or reading from this image type. Must be a scalar <a href=\"#Numerical\">numerical type</a> or <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n<br />\n<em>Dim</em> is the image <a href=\"#Dim\">dimensionality</a> (Dim).<br />\n<br />\n<em>Depth</em> is whether or not this image is a depth image. (Note that whether or not depth comparisons are actually done is a property of the sampling opcode, not of this type declaration.)<br />\n0 indicates not a depth image<br />\n1 indicates a depth image<br />\n2 means no indication as to whether this is a depth or non-depth image<br />\n<br />\n<em>Arrayed</em> must be one of the following indicated values:<br />\n0 indicates non-arrayed content<br />\n1 indicates arrayed content<br />\n<br />\n<em>MS</em> must be one of the following indicated values:<br />\n0 indicates single-sampled content<br />\n1 indicates multisampled content<br />\n<br />\n<em>Sampled</em> indicates whether or not this image will be accessed in combination with a <a href=\"#Sampler\">sampler</a>, and must be one of the following values:<br />\n0 indicates this is only known at run time, not at compile time<br />\n1 indicates will be used with sampler<br />\n2 indicates will be used without a sampler (a storage image)<br />\n<br />\n<em>Image Format</em> is the <a href=\"#Image_Format\">Image Format</a>, which can be <strong>Unknown</strong>, depending on the client API.<br />\n<br />\nIf <a href=\"#Dim\"><em>Dim</em></a> is <strong>SubpassData</strong>, <em>Sampled</em> must be 2, <em>Image Format</em> must be <strong>Unknown</strong>, and the <a href=\"#Execution_Model\">Execution Model</a> must be <strong>Fragment</strong>.<br />\n<br />\n<em>Access Qualifier</em> is an image <a href=\"#Access_Qualifier\"><strong>Access Qualifier</strong></a>.",
    "DescriptionPlain": "OpTypeImage\n\nDeclare a new image type. Consumed, for example, by OpTypeSampledImage. This type is opaque: values of this type have no defined physical size or bit pattern.\n\nSampled Type is the type of the components that result from sampling or reading from this image type. Must be a scalar numerical type or OpTypeVoid.\n\nDim is the image dimensionality (Dim).\n\nDepth is whether or not this image is a depth image. (Note that whether or not depth comparisons are actually done is a property of the sampling opcode, not of this type declaration.)\n0 indicates not a depth image\n1 indicates a depth image\n2 means no indication as to whether this is a depth or non-depth image\n\nArrayed must be one of the following indicated values:\n0 indicates non-arrayed content\n1 indicates arrayed content\n\nMS must be one of the following indicated values:\n0 indicates single-sampled content\n1 indicates multisampled content\n\nSampled indicates whether or not this image will be accessed in combination with a sampler, and must be one of the following values:\n0 indicates this is only known at run time, not at compile time\n1 indicates will be used with sampler\n2 indicates will be used without a sampler (a storage image)\n\nImage Format is the Image Format, which can be Unknown, depending on the client API.\n\nIf Dim is SubpassData, Sampled must be 2, Image Format must be Unknown, and the Execution Model must be Fragment.\n\nAccess Qualifier is an image Access Qualifier.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "9 + variable",
    "WordCountFix": 9,
    "OpCode": 25,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledType",
        "Type": "ID"
      },
      {
        "Name": "Dim",
        "Type": "Dim"
      },
      {
        "Name": "Depth",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Arrayed",
        "Type": "LiteralNumber"
      },
      {
        "Name": "MS",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Sampled",
        "Type": "LiteralNumber"
      },
      {
        "Name": "ImageFormat",
        "Type": "ImageFormat"
      },
      {
        "Name": "Qualifier",
        "Type": "OptionalAccess"
      }
    ]
  },
  {
    "Name": "OpTypeSampler",
    "Description": "<a id=\"OpTypeSampler\"></a><strong>OpTypeSampler</strong><br />\n<br />\nDeclare the <a href=\"#Sampler\">sampler</a> type. Consumed by <a href=\"#OpSampledImage\"><strong>OpSampledImage</strong></a>. This type is opaque: values of this type have no defined physical size or bit pattern.",
    "DescriptionPlain": "OpTypeSampler\n\nDeclare the sampler type. Consumed by OpSampledImage. This type is opaque: values of this type have no defined physical size or bit pattern.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 26,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeSampledImage",
    "Description": "<a id=\"OpTypeSampledImage\"></a><strong>OpTypeSampledImage</strong><br />\n<br />\nDeclare a <a href=\"#SampledImage\">sampled image</a> type, the <em>Result Type</em> of <a href=\"#OpSampledImage\"><strong>OpSampledImage</strong></a>, or an externally combined sampler and image. This type is opaque: values of this type have no defined physical size or bit pattern.<br />\n<br />\n<em>Image Type</em> must be an <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.  It is the type of the image in the combined sampler and image type.",
    "DescriptionPlain": "OpTypeSampledImage\n\nDeclare a sampled image type, the Result Type of OpSampledImage, or an externally combined sampler and image. This type is opaque: values of this type have no defined physical size or bit pattern.\n\nImage Type must be an OpTypeImage.  It is the type of the image in the combined sampler and image type.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 27,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ImageType",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeArray",
    "Description": "<a id=\"OpTypeArray\"></a><strong>OpTypeArray</strong><br />\n<br />\nDeclare a new array type: a dynamically-indexable ordered aggregate of elements all having the same type.<br />\n<br />\n<em>Element Type</em> is the type of each element in the array.<br />\n<br />\n<em>Length</em> is the number of elements in the array.  It must be at least 1. <em>Length</em> must come from a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of an <a href=\"#Integer\"><em>integer-type</em></a> scalar whose value is at least 1.<br />\n<br />\nArray elements are number consecutively, starting with 0.",
    "DescriptionPlain": "OpTypeArray\n\nDeclare a new array type: a dynamically-indexable ordered aggregate of elements all having the same type.\n\nElement Type is the type of each element in the array.\n\nLength is the number of elements in the array.  It must be at least 1. Length must come from a constant instruction of an integer-type scalar whose value is at least 1.\n\nArray elements are number consecutively, starting with 0.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 28,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ElementType",
        "Type": "ID"
      },
      {
        "Name": "Length",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeRuntimeArray",
    "Description": "<a id=\"OpTypeRuntimeArray\"></a><strong>OpTypeRuntimeArray</strong><br />\n<br />\nDeclare a new run-time array type.  Its length is not known at compile time.<br />\n<br />\n<em>Element Type</em> is the type of each element in the array. It must be a <a href=\"#Concrete\">concrete</a> type.<br />\n<br />\n See <a href=\"#OpArrayLength\"><strong>OpArrayLength</strong></a> for getting the <em>Length</em> of an array of this type.<br />\n<br />\n<a href=\"#Object\">Objects</a> of this type can only be created with <a href=\"#OpVariable\"><strong>OpVariable</strong></a> using the <strong>Uniform</strong> <a href=\"#Storage_Class\">Storage Class</a>.",
    "DescriptionPlain": "OpTypeRuntimeArray\n\nDeclare a new run-time array type.  Its length is not known at compile time.\n\nElement Type is the type of each element in the array. It must be a concrete type.\n\n See OpArrayLength for getting the Length of an array of this type.\n\nObjects of this type can only be created with OpVariable using the Uniform Storage Class.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 29,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ElementType",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeStruct",
    "Description": "<a id=\"OpTypeStruct\"></a><strong>OpTypeStruct</strong><br />\n<br />\nDeclare a new structure type: an aggregate of potentially heterogeneous members.<br />\n<br />\n<em>Member N type</em> is the type of member <em>N</em> of the structure. The first member is member 0, the next is member 1, &#8230;<br />\n<br />\nIf an operand is not yet defined, it must be defined by an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>, where the type pointed to is an <strong>OpTypeStruct</strong>.",
    "DescriptionPlain": "OpTypeStruct\n\nDeclare a new structure type: an aggregate of potentially heterogeneous members.\n\nMember N type is the type of member N of the structure. The first member is member 0, the next is member 1, &#8230;\n\nIf an operand is not yet defined, it must be defined by an OpTypePointer, where the type pointed to is an OpTypeStruct.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "2 + variable",
    "WordCountFix": 2,
    "OpCode": 30,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Members",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpTypeOpaque",
    "Description": "<a id=\"OpTypeOpaque\"></a><strong>OpTypeOpaque</strong><br />\n<br />\nDeclare a structure type with no body specified.",
    "DescriptionPlain": "OpTypeOpaque\n\nDeclare a structure type with no body specified.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 31,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "TheNameOfTheOpaqueType",
        "Type": "LiteralString"
      }
    ]
  },
  {
    "Name": "OpTypePointer",
    "Description": "<a id=\"OpTypePointer\"></a><strong>OpTypePointer</strong><br />\n<br />\nDeclare a new pointer type.<br />\n<br />\n<em>Storage Class</em> is the <a href=\"#Storage_Class\">Storage Class</a> of the memory holding the object pointed to. If there was a forward reference to this type from an <a href=\"#OpTypeForwardPointer\"><strong>OpTypeForwardPointer</strong></a>, the <em>Storage Class</em> of that instruction must equal the <em>Storage Class</em> of this instruction.<br />\n<br />\n<em>Type</em> is the type of the object pointed to.",
    "DescriptionPlain": "OpTypePointer\n\nDeclare a new pointer type.\n\nStorage Class is the Storage Class of the memory holding the object pointed to. If there was a forward reference to this type from an OpTypeForwardPointer, the Storage Class of that instruction must equal the Storage Class of this instruction.\n\nType is the type of the object pointed to.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 32,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "StorageClass",
        "Type": "StorageClass"
      },
      {
        "Name": "Type",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeFunction",
    "Description": "<a id=\"OpTypeFunction\"></a><strong>OpTypeFunction</strong><br />\n<br />\nDeclare a new function type.<br />\n<br />\n<a href=\"#OpFunction\"><strong>OpFunction</strong></a> will use this to declare the return type and parameter types of a function. <strong>OpFunction</strong> is the only valid use of <strong>OpTypeFunction</strong>.<br />\n<br />\n<em>Return Type</em> is the type of the return value of functions of this type. It must be a <a href=\"#Concrete\">concrete</a> or <a href=\"#Abstract\">abstract</a> type, or a pointer to such a type. If the function has no return value, <em>Return Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n<br />\n<em>Parameter N Type</em> is the type <em>&lt;id&gt;</em> of the type of parameter <em>N</em>.",
    "DescriptionPlain": "OpTypeFunction\n\nDeclare a new function type.\n\nOpFunction will use this to declare the return type and parameter types of a function. OpFunction is the only valid use of OpTypeFunction.\n\nReturn Type is the type of the return value of functions of this type. It must be a concrete or abstract type, or a pointer to such a type. If the function has no return value, Return Type must be OpTypeVoid.\n\nParameter N Type is the type &lt;id&gt; of the type of parameter N.",
    "Category": "Type-Declaration",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 33,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ReturnType",
        "Type": "ID"
      },
      {
        "Name": "Parameters",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpTypeEvent",
    "Description": "<a id=\"OpTypeEvent\"></a><strong>OpTypeEvent</strong><br />\n<br />\nDeclare an OpenCL event type.",
    "DescriptionPlain": "OpTypeEvent\n\nDeclare an OpenCL event type.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 34,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeDeviceEvent",
    "Description": "<a id=\"OpTypeDeviceEvent\"></a><strong>OpTypeDeviceEvent</strong><br />\n<br />\nDeclare an OpenCL device-side event type.",
    "DescriptionPlain": "OpTypeDeviceEvent\n\nDeclare an OpenCL device-side event type.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 35,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeReserveId",
    "Description": "<a id=\"OpTypeReserveId\"></a><strong>OpTypeReserveId</strong><br />\n<br />\nDeclare an OpenCL reservation id type.",
    "DescriptionPlain": "OpTypeReserveId\n\nDeclare an OpenCL reservation id type.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 36,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeQueue",
    "Description": "<a id=\"OpTypeQueue\"></a><strong>OpTypeQueue</strong><br />\n<br />\nDeclare an OpenCL queue type.",
    "DescriptionPlain": "OpTypeQueue\n\nDeclare an OpenCL queue type.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 37,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypePipe",
    "Description": "<a id=\"OpTypePipe\"></a><strong>OpTypePipe</strong><br />\n<br />\nDeclare an OpenCL pipe type.<br />\n<br />\n<em>Qualifier</em> is the pipe access qualifier.",
    "DescriptionPlain": "OpTypePipe\n\nDeclare an OpenCL pipe type.\n\nQualifier is the pipe access qualifier.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 38,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Qualifier",
        "Type": "AccessQualifier"
      }
    ]
  },
  {
    "Name": "OpTypeForwardPointer",
    "Description": "<a id=\"OpTypeForwardPointer\"></a><strong>OpTypeForwardPointer</strong><br />\n<br />\nDeclare the Storage Class for a forward reference to a pointer.<br />\n<br />\n<em>Pointer Type</em> is a forward reference to the result of an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. The type of object the pointer points to is declared by the <strong>OpTypePointer</strong> instruction, not this instruction. Subsequent <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> instructions can use <em>Pointer Type</em> as an operand.<br />\n<br />\n<em>Storage Class</em> is the <a href=\"#Storage_Class\">Storage Class</a> of the memory holding the object pointed to.",
    "DescriptionPlain": "OpTypeForwardPointer\n\nDeclare the Storage Class for a forward reference to a pointer.\n\nPointer Type is a forward reference to the result of an OpTypePointer. The type of object the pointer points to is declared by the OpTypePointer instruction, not this instruction. Subsequent OpTypeStruct instructions can use Pointer Type as an operand.\n\nStorage Class is the Storage Class of the memory holding the object pointed to.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 39,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "PointerType",
        "Type": "ID"
      },
      {
        "Name": "StorageClass",
        "Type": "StorageClass"
      }
    ]
  },
  {
    "Name": "OpTypePipeStorage",
    "Description": "<a id=\"OpTypePipeStorage\"></a><strong>OpTypePipeStorage</strong><br />\n<br />\nDeclare the OpenCL pipe-storage type.",
    "DescriptionPlain": "OpTypePipeStorage\n\nDeclare the OpenCL pipe-storage type.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 322,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTypeNamedBarrier",
    "Description": "<a id=\"OpTypeNamedBarrier\"></a><strong>OpTypeNamedBarrier</strong><br />\n<br />\nDeclare the named-barrier type.",
    "DescriptionPlain": "OpTypeNamedBarrier\n\nDeclare the named-barrier type.",
    "Category": "Type-Declaration",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 327,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConstantTrue",
    "Description": "<a id=\"OpConstantTrue\"></a><strong>OpConstantTrue</strong><br />\n<br />\nDeclare a <strong>true</strong> <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar constant.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.",
    "DescriptionPlain": "OpConstantTrue\n\nDeclare a true Boolean-type scalar constant.\n\nResult Type must be the scalar Boolean type.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 41,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConstantFalse",
    "Description": "<a id=\"OpConstantFalse\"></a><strong>OpConstantFalse</strong><br />\n<br />\nDeclare a <strong>false</strong> <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar constant.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.",
    "DescriptionPlain": "OpConstantFalse\n\nDeclare a false Boolean-type scalar constant.\n\nResult Type must be the scalar Boolean type.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 42,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConstant",
    "Description": "<a id=\"OpConstant\"></a><strong>OpConstant</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>integer-type</em></a> or <a href=\"#Floating\"><em>floating-point-type</em></a> scalar constant.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.<br />\n<br />\n<em>Value</em> is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.",
    "DescriptionPlain": "OpConstant\n\nDeclare a new integer-type or floating-point-type scalar constant.\n\nResult Type must be a scalar integer type or floating-point type.\n\nValue is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 43,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpConstantComposite",
    "Description": "<a id=\"OpConstantComposite\"></a><strong>OpConstantComposite</strong><br />\n<br />\nDeclare a new <a href=\"#CompositeType\"><em>composite</em></a> constant.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#CompositeType\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the <em>Constituents</em>. The ordering must be the same between the top-level types in <em>Result Type</em> and the <em>Constituents</em>.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result. The <em>Constituents</em> must appear in the order needed by the definition of the <em>Result Type</em>. The <em>Constituents</em> must all be <em>&lt;id&gt;s</em> of other constant declarations or an <a href=\"#OpUndef\"><strong>OpUndef</strong></a>.",
    "DescriptionPlain": "OpConstantComposite\n\nDeclare a new composite constant.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the Constituents. The ordering must be the same between the top-level types in Result Type and the Constituents.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the Result Type. The Constituents must all be &lt;id&gt;s of other constant declarations or an OpUndef.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 44,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Constituents",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpConstantSampler",
    "Description": "<a id=\"OpConstantSampler\"></a><strong>OpConstantSampler</strong><br />\n<br />\nDeclare a new sampler constant.<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Sampler Addressing Mode</em> is the addressing mode; a literal from <a href=\"#Sampler_Addressing_Mode\">Sampler Addressing Mode</a>.<br />\n<br />\n<em>Param</em> is one of:<br />\n0: Non Normalized<br />\n1: Normalized<br />\n<br />\n<em>Sampler Filter Mode</em> is the filter mode; a literal from <a href=\"#Sampler_Filter_Mode\">Sampler Filter Mode</a>.",
    "DescriptionPlain": "OpConstantSampler\n\nDeclare a new sampler constant.\n\nResult Type must be OpTypeSampler.\n\nSampler Addressing Mode is the addressing mode; a literal from Sampler Addressing Mode.\n\nParam is one of:\n0: Non Normalized\n1: Normalized\n\nSampler Filter Mode is the filter mode; a literal from Sampler Filter Mode.",
    "Category": "Constant-Creation",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 45,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SamplerAddressingMode",
        "Type": "SamplerAddressingMode"
      },
      {
        "Name": "Param",
        "Type": "LiteralNumber"
      },
      {
        "Name": "SamplerFilterMode",
        "Type": "SamplerFilterMode"
      }
    ]
  },
  {
    "Name": "OpConstantNull",
    "Description": "<a id=\"OpConstantNull\"></a><strong>OpConstantNull</strong><br />\n<br />\nDeclare a new <em>null</em> constant value.<br />\n<br />\nThe <em>null</em> value is type dependent, defined as follows:<br />\n -  Scalar Boolean: <strong>false</strong><br />\n -  Scalar integer: 0<br />\n -  Scalar floating point: +0.0 (all bits 0)<br />\n -  All other scalars: Abstract<br />\n -  Composites: Members are set recursively to the null constant according to the null value of their constituent types.<br />\n<br />\n<em>Result Type</em> must be one of the following types:<br />\n -  Scalar or vector <a href=\"#Boolean\"><em>Boolean type</em></a><br />\n -  Scalar or vector <a href=\"#Integer\"><em>integer type</em></a><br />\n -  Scalar or vector <a href=\"#Floating\"><em>floating-point type</em></a><br />\n -  Pointer type<br />\n -  <a href=\"#OpTypeEvent\"><em>Event type</em></a><br />\n -  <a href=\"#OpTypeDeviceEvent\"><em>Device side event type</em></a><br />\n -  <a href=\"#OpTypeReserveId\"><em>Reservation id type</em></a><br />\n -  <a href=\"#OpTypeQueue\"><em>Queue type</em></a><br />\n -  <a href=\"#CompositeType\"><em>Composite type</em></a>",
    "DescriptionPlain": "OpConstantNull\n\nDeclare a new null constant value.\n\nThe null value is type dependent, defined as follows:\n -  Scalar Boolean: false\n -  Scalar integer: 0\n -  Scalar floating point: +0.0 (all bits 0)\n -  All other scalars: Abstract\n -  Composites: Members are set recursively to the null constant according to the null value of their constituent types.\n\nResult Type must be one of the following types:\n -  Scalar or vector Boolean type\n -  Scalar or vector integer type\n -  Scalar or vector floating-point type\n -  Pointer type\n -  Event type\n -  Device side event type\n -  Reservation id type\n -  Queue type\n -  Composite type",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 46,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSpecConstantTrue",
    "Description": "<a id=\"OpSpecConstantTrue\"></a><strong>OpSpecConstantTrue</strong><br />\n<br />\nDeclare a <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar specialization constant with a default value of <strong>true</strong>.<br />\n<br />\nThis instruction can be specialized to become either an <a href=\"#OpConstantTrue\"><strong>OpConstantTrue</strong></a> or <a href=\"#OpConstantFalse\"><strong>OpConstantFalse</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
    "DescriptionPlain": "OpSpecConstantTrue\n\nDeclare a Boolean-type scalar specialization constant with a default value of true.\n\nThis instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.\n\nResult Type must be the scalar Boolean type.\n\nSee Specialization.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 48,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSpecConstantFalse",
    "Description": "<a id=\"OpSpecConstantFalse\"></a><strong>OpSpecConstantFalse</strong><br />\n<br />\nDeclare a <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar specialization constant with a default value of <strong>false</strong>.<br />\n<br />\nThis instruction can be specialized to become either an <a href=\"#OpConstantTrue\"><strong>OpConstantTrue</strong></a> or <a href=\"#OpConstantFalse\"><strong>OpConstantFalse</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
    "DescriptionPlain": "OpSpecConstantFalse\n\nDeclare a Boolean-type scalar specialization constant with a default value of false.\n\nThis instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.\n\nResult Type must be the scalar Boolean type.\n\nSee Specialization.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 49,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSpecConstant",
    "Description": "<a id=\"OpSpecConstant\"></a><strong>OpSpecConstant</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>integer-type</em></a> or <a href=\"#Floating\"><em>floating-point-type</em></a> scalar specialization constant.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.<br />\n<br />\n<em>Value</em> is the bit pattern for the default value of the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.<br />\n<br />\nThis instruction can be specialized to become an <a href=\"#OpConstant\"><strong>OpConstant</strong></a> instruction.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
    "DescriptionPlain": "OpSpecConstant\n\nDeclare a new integer-type or floating-point-type scalar specialization constant.\n\nResult Type must be a scalar integer type or floating-point type.\n\nValue is the bit pattern for the default value of the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.\n\nThis instruction can be specialized to become an OpConstant instruction.\n\nSee Specialization.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 50,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpSpecConstantComposite",
    "Description": "<a id=\"OpSpecConstantComposite\"></a><strong>OpSpecConstantComposite</strong><br />\n<br />\nDeclare a new <a href=\"#CompositeType\"><em>composite</em></a> specialization constant.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#CompositeType\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the <em>Constituents</em>. The ordering must be the same between the top-level types in <em>Result Type</em> and the <em>Constituents</em>.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result. The <em>Constituents</em> must appear in the order needed by the definition of the type of the result. The <em>Constituents</em> must be the <em>&lt;id&gt;</em> of other specialization constant or constant declarations.<br />\n<br />\nThis instruction will be specialized to an <a href=\"#OpConstantComposite\"><strong>OpConstantComposite</strong></a> instruction.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
    "DescriptionPlain": "OpSpecConstantComposite\n\nDeclare a new composite specialization constant.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the Constituents. The ordering must be the same between the top-level types in Result Type and the Constituents.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the type of the result. The Constituents must be the &lt;id&gt; of other specialization constant or constant declarations.\n\nThis instruction will be specialized to an OpConstantComposite instruction.\n\nSee Specialization.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 51,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Constituents",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpSpecConstantOp",
    "Description": "<a id=\"OpSpecConstantOp\"></a><strong>OpSpecConstantOp</strong><br />\n<br />\nDeclare a new specialization constant that results from doing an operation.<br />\n<br />\n<em>Result Type</em> must be the type required by the <em>Result Type</em> of <em>Opcode</em>.<br />\n<br />\n<em>Opcode</em> must be one of the following opcodes. This literal operand is limited to a single <a href=\"#Word\">word</a>.<br />\n<strong>OpSConvert</strong>, <strong>OpFConvert</strong><br />\n<strong>OpSNegate</strong>, <strong>OpNot</strong><br />\n<strong>OpIAdd</strong>, <strong>OpISub</strong><br />\n<strong>OpIMul</strong>, <strong>OpUDiv</strong>, <strong>OpSDiv</strong>, <strong>OpUMod</strong>, <strong>OpSRem</strong>, <strong>OpSMod</strong><br />\n<strong>OpShiftRightLogical</strong>, <strong>OpShiftRightArithmetic</strong>, <strong>OpShiftLeftLogical</strong><br />\n<strong>OpBitwiseOr</strong>, <strong>OpBitwiseXor</strong>, <strong>OpBitwiseAnd</strong><br />\n<strong>OpVectorShuffle</strong>, <strong>OpCompositeExtract</strong>, <strong>OpCompositeInsert</strong><br />\n<strong>OpLogicalOr</strong>, <strong>OpLogicalAnd</strong>, <strong>OpLogicalNot</strong>,<br />\n<strong>OpLogicalEqual</strong>, <strong>OpLogicalNotEqual</strong><br />\n<strong>OpSelect</strong><br />\n<strong>OpIEqual</strong>, <strong>OpINotEqual</strong><br />\n<strong>OpULessThan</strong>, <strong>OpSLessThan</strong><br />\n<strong>OpUGreaterThan</strong>, <strong>OpSGreaterThan</strong><br />\n<strong>OpULessThanEqual</strong>, <strong>OpSLessThanEqual</strong><br />\n<strong>OpUGreaterThanEqual</strong>, <strong>OpSGreaterThanEqual</strong><br />\n<br />\nIf the <strong>Shader</strong> capability was declared, the following opcode is also valid:<br />\n<strong>OpQuantizeToF16</strong><br />\n<br />\nIf the <strong>Kernel</strong> capability was declared, the following opcodes are also valid:<br />\n<strong>OpConvertFToS</strong>, <strong>OpConvertSToF</strong><br />\n<strong>OpConvertFToU</strong>, <strong>OpConvertUToF</strong><br />\n<strong>OpUConvert</strong><br />\n<strong>OpConvertPtrToU</strong>, <strong>OpConvertUToPtr</strong><br />\n<strong>OpGenericCastToPtr</strong>, <strong>OpPtrCastToGeneric</strong><br />\n<strong>OpBitcast</strong><br />\n<strong>OpFNegate</strong><br />\n<strong>OpFAdd</strong>, <strong>OpFSub</strong><br />\n<strong>OpFMul</strong>, <strong>OpFDiv</strong><br />\n<strong>OpFRem</strong>, <strong>OpFMod</strong><br />\n<strong>OpAccessChain</strong>, <strong>OpInBoundsAccessChain</strong><br />\n<strong>OpPtrAccessChain</strong>, <strong>OpInBoundsPtrAccessChain</strong><br />\n<br />\n<em>Operands</em> are the operands required by <em>opcode</em>, and satisfy the semantics of <em>opcode</em>. In addition, all <em>Operands</em> must be either:<br />\n - the <em>&lt;id&gt;s</em> of other <a href=\"#ConstantInstruction\">constant instructions</a>, or<br />\n - <strong>OpUndef</strong>, when allowed by <em>opcode</em>, or<br />\n - for the <strong>AccessChain</strong> named opcodes, their <em>Base</em> is allowed to be a global (module scope) <a href=\"#OpVariable\"><strong>OpVariable</strong></a> instruction.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
    "DescriptionPlain": "OpSpecConstantOp\n\nDeclare a new specialization constant that results from doing an operation.\n\nResult Type must be the type required by the Result Type of Opcode.\n\nOpcode must be one of the following opcodes. This literal operand is limited to a single word.\nOpSConvert, OpFConvert\nOpSNegate, OpNot\nOpIAdd, OpISub\nOpIMul, OpUDiv, OpSDiv, OpUMod, OpSRem, OpSMod\nOpShiftRightLogical, OpShiftRightArithmetic, OpShiftLeftLogical\nOpBitwiseOr, OpBitwiseXor, OpBitwiseAnd\nOpVectorShuffle, OpCompositeExtract, OpCompositeInsert\nOpLogicalOr, OpLogicalAnd, OpLogicalNot,\nOpLogicalEqual, OpLogicalNotEqual\nOpSelect\nOpIEqual, OpINotEqual\nOpULessThan, OpSLessThan\nOpUGreaterThan, OpSGreaterThan\nOpULessThanEqual, OpSLessThanEqual\nOpUGreaterThanEqual, OpSGreaterThanEqual\n\nIf the Shader capability was declared, the following opcode is also valid:\nOpQuantizeToF16\n\nIf the Kernel capability was declared, the following opcodes are also valid:\nOpConvertFToS, OpConvertSToF\nOpConvertFToU, OpConvertUToF\nOpUConvert\nOpConvertPtrToU, OpConvertUToPtr\nOpGenericCastToPtr, OpPtrCastToGeneric\nOpBitcast\nOpFNegate\nOpFAdd, OpFSub\nOpFMul, OpFDiv\nOpFRem, OpFMod\nOpAccessChain, OpInBoundsAccessChain\nOpPtrAccessChain, OpInBoundsPtrAccessChain\n\nOperands are the operands required by opcode, and satisfy the semantics of opcode. In addition, all Operands must be either:\n - the &lt;id&gt;s of other constant instructions, or\n - OpUndef, when allowed by opcode, or\n - for the AccessChain named opcodes, their Base is allowed to be a global (module scope) OpVariable instruction.\n\nSee Specialization.",
    "Category": "Constant-Creation",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 52,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Opcode",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Operands",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpVariable",
    "Description": "<a id=\"OpVariable\"></a><strong>OpVariable</strong><br />\n<br />\nAllocate an object in memory, resulting in a pointer to it, which can be used with <a href=\"#OpLoad\"><strong>OpLoad</strong></a> and <a href=\"#OpStore\"><strong>OpStore</strong></a>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <em>Type</em> operand is the type of object in memory.<br />\n<br />\n<em>Storage Class</em> is the <a href=\"#Storage_Class\">Storage Class</a> of the memory holding the object. It cannot be <strong>Generic</strong>.<br />\n<br />\n<em>Initializer</em> is optional.  If <em>Initializer</em> is present, it will be the initial value of the variable&#8217;s memory content. <em>Initializer</em> must be an <em>&lt;id&gt;</em> from a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> or a global (module scope) <a href=\"#OpVariable\"><strong>OpVariable</strong></a> instruction. <em>Initializer</em> must have the same type as the type pointed to by <em>Result Type</em>.",
    "DescriptionPlain": "OpVariable\n\nAllocate an object in memory, resulting in a pointer to it, which can be used with OpLoad and OpStore.\n\n Result Type must be an OpTypePointer. Its Type operand is the type of object in memory.\n\nStorage Class is the Storage Class of the memory holding the object. It cannot be Generic.\n\nInitializer is optional.  If Initializer is present, it will be the initial value of the variable&#8217;s memory content. Initializer must be an &lt;id&gt; from a constant instruction or a global (module scope) OpVariable instruction. Initializer must have the same type as the type pointed to by Result Type.",
    "Category": "Memory",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 59,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "StorageClass",
        "Type": "StorageClass"
      },
      {
        "Name": "Initializer",
        "Type": "ID?"
      }
    ]
  },
  {
    "Name": "OpImageTexelPointer",
    "Description": "<a id=\"OpImageTexelPointer\"></a><strong>OpImageTexelPointer</strong><br />\n<br />\nForm a pointer to a texel of an image. Use of such a pointer is limited to atomic operations.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose <a href=\"#Storage_Class\"><em>Storage Class</em></a> operand is <strong>Image</strong>. Its <em>Type</em> operand must be a scalar <a href=\"#Numerical\">numerical type</a> or <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n<br />\n<em>Image</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <em>Type</em> <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. The <em>Sampled Type</em> of the type of <em>Image</em> must be the same as the <em>Type</em> pointed to by <em>Result Type</em>. The <a href=\"#Dim\"><em>Dim</em></a> operand of <em>Type</em> cannot be <strong>SubpassData</strong>.<br />\n<br />\n<em>Coordinate</em> and <em>Sample</em> specify which texel and sample within the image to form a pointer to.<br />\n<br />\n<em>Coordinate</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the number of components specified below, given the following <em>Arrayed</em> and <a href=\"#Dim\"><em>Dim</em></a> operands of the type of the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\nIf <em>Arrayed</em> is 0:<br />\n<strong>1D</strong>: scalar<br />\n<strong>2D</strong>: 2 components<br />\n<strong>3D</strong>: 3 components<br />\n<strong>Cube</strong>: 3 components<br />\n<strong>Rect</strong>: 2 components<br />\n<strong>Buffer</strong>: scalar<br />\n<br />\nIf <em>Arrayed</em> is 1:<br />\n<strong>1D</strong>: 2 components<br />\n<strong>2D</strong>: 3 components<br />\n<strong>Cube</strong>: 4 components<br />\n<br />\n<em>Sample</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. It specifies which sample to select at the given coordinate.  It must be a valid <em>&lt;id&gt;</em> for the value 0 if the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> has <em>MS</em> of 0.",
    "DescriptionPlain": "OpImageTexelPointer\n\nForm a pointer to a texel of an image. Use of such a pointer is limited to atomic operations.\n\nResult Type must be an OpTypePointer whose Storage Class operand is Image. Its Type operand must be a scalar numerical type or OpTypeVoid.\n\nImage must have a type of OpTypePointer with Type OpTypeImage. The Sampled Type of the type of Image must be the same as the Type pointed to by Result Type. The Dim operand of Type cannot be SubpassData.\n\nCoordinate and Sample specify which texel and sample within the image to form a pointer to.\n\nCoordinate must be a scalar or vector of integer type.  It must have the number of components specified below, given the following Arrayed and Dim operands of the type of the OpTypeImage.\n\nIf Arrayed is 0:\n1D: scalar\n2D: 2 components\n3D: 3 components\nCube: 3 components\nRect: 2 components\nBuffer: scalar\n\nIf Arrayed is 1:\n1D: 2 components\n2D: 3 components\nCube: 4 components\n\nSample must be an integer type scalar. It specifies which sample to select at the given coordinate.  It must be a valid &lt;id&gt; for the value 0 if the OpTypeImage has MS of 0.",
    "Category": "Memory",
    "Capabilities": [],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 60,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Sample",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpLoad",
    "Description": "<a id=\"OpLoad\"></a><strong>OpLoad</strong><br />\n<br />\nLoad through a pointer.<br />\n<br />\n<em>Result Type</em> is the type of the loaded object.<br />\n<br />\n<em>Pointer</em> is the pointer to load through.  Its type must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose <em>Type</em> operand is the same as <em>Result Type</em>.<br />\n<br />\n<em>Memory Access</em> must be a <a href=\"#Memory_Access\">Memory Access</a> literal. If not present, it is the same as specifying <strong>None</strong>.",
    "DescriptionPlain": "OpLoad\n\nLoad through a pointer.\n\nResult Type is the type of the loaded object.\n\nPointer is the pointer to load through.  Its type must be an OpTypePointer whose Type operand is the same as Result Type.\n\nMemory Access must be a Memory Access literal. If not present, it is the same as specifying None.",
    "Category": "Memory",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 61,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "Access",
        "Type": "OptionalMemory"
      }
    ]
  },
  {
    "Name": "OpStore",
    "Description": "<a id=\"OpStore\"></a><strong>OpStore</strong><br />\n<br />\nStore through a pointer.<br />\n<br />\n<em>Pointer</em> is the pointer to store through.  Its type must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose <em>Type</em> operand is the same as the type of <em>Object</em>.<br />\n<br />\n<em>Object</em> is the object to store.<br />\n<br />\n<em>Memory Access</em> must be a <a href=\"#Memory_Access\">Memory Access</a> literal. If not present, it is the same as specifying <strong>None</strong>.",
    "DescriptionPlain": "OpStore\n\nStore through a pointer.\n\nPointer is the pointer to store through.  Its type must be an OpTypePointer whose Type operand is the same as the type of Object.\n\nObject is the object to store.\n\nMemory Access must be a Memory Access literal. If not present, it is the same as specifying None.",
    "Category": "Memory",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 62,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Access",
        "Type": "OptionalMemory"
      }
    ]
  },
  {
    "Name": "OpCopyMemory",
    "Description": "<a id=\"OpCopyMemory\"></a><strong>OpCopyMemory</strong><br />\n<br />\nCopy from the memory pointed to by <em>Source</em> to the memory pointed to by <em>Target</em>. Both operands must be non-void pointers of the same type.  Matching Storage Class is not required. The amount of memory copied is the size of the type pointed to.<br />\n<br />\n<em>Memory Access</em> must be a <a href=\"#Memory_Access\">Memory Access</a> literal. If not present, it is the same as specifying <strong>None</strong>.",
    "DescriptionPlain": "OpCopyMemory\n\nCopy from the memory pointed to by Source to the memory pointed to by Target. Both operands must be non-void pointers of the same type.  Matching Storage Class is not required. The amount of memory copied is the size of the type pointed to.\n\nMemory Access must be a Memory Access literal. If not present, it is the same as specifying None.",
    "Category": "Memory",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 63,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Target",
        "Type": "ID"
      },
      {
        "Name": "Source",
        "Type": "ID"
      },
      {
        "Name": "Access",
        "Type": "OptionalMemory"
      }
    ]
  },
  {
    "Name": "OpCopyMemorySized",
    "Description": "<a id=\"OpCopyMemorySized\"></a><strong>OpCopyMemorySized</strong><br />\n<br />\nCopy from the memory pointed to by <em>Source</em> to the memory pointed to by <em>Target</em>. <br />\n<br />\n<em>Size</em> is the number of bytes to copy. It must have a scalar <a href=\"#Integer\">integer type</a>. If it is a <a href=\"#ConstantInstruction\">constant instruction</a>, the constant value cannot be 0. It is invalid for both the constant&#8217;s type to have <em>Signedness</em> of 1 and to have the sign bit set. Otherwise, as a run-time value, <em>Size</em> is treated as unsigned, and if its value is 0, no memory access will be made.<br />\n<br />\n<em>Memory Access</em> must be a <a href=\"#Memory_Access\">Memory Access</a> literal. If not present, it is the same as specifying <strong>None</strong>.",
    "DescriptionPlain": "OpCopyMemorySized\n\nCopy from the memory pointed to by Source to the memory pointed to by Target. \n\nSize is the number of bytes to copy. It must have a scalar integer type. If it is a constant instruction, the constant value cannot be 0. It is invalid for both the constant&#8217;s type to have Signedness of 1 and to have the sign bit set. Otherwise, as a run-time value, Size is treated as unsigned, and if its value is 0, no memory access will be made.\n\nMemory Access must be a Memory Access literal. If not present, it is the same as specifying None.",
    "Category": "Memory",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 64,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Target",
        "Type": "ID"
      },
      {
        "Name": "Source",
        "Type": "ID"
      },
      {
        "Name": "Size",
        "Type": "ID"
      },
      {
        "Name": "Access",
        "Type": "OptionalMemory"
      }
    ]
  },
  {
    "Name": "OpAccessChain",
    "Description": "<a id=\"OpAccessChain\"></a><strong>OpAccessChain</strong><br />\n<br />\nCreate a pointer into a <a href=\"#CompositeType\"><em>composite</em></a> object that can be used with <a href=\"#OpLoad\"><strong>OpLoad</strong></a> and <a href=\"#OpStore\"><strong>OpStore</strong></a>. <br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <em>Type</em> operand must be the type reached by walking the <em>Base&#8217;s</em> type hierarchy down to the last provided index in <em>Indexes</em>, and its <em>Storage Class</em> operand must be the same as the Storage Class of <em>Base</em>.<br />\n<br />\n<em>Base</em> must be a pointer, pointing to the base of a composite object.<br />\n<br />\n<em>Indexes</em> walk the type hierarchy to the desired depth, potentially down to scalar granularity. The first index in <em>Indexes</em> will select the top-level member/element/component/element of the base composite. All composite constituents use zero-based numbering, as described by their <strong>OpType&#8230;</strong> instruction. The second index will apply similarly to that result, and so on. Once any non-composite type is reached, there must be no remaining (unused) indexes. Each of the <em>Indexes</em> must:<br />\n- be a scalar <a href=\"#Integer\">integer type</a>,<br />\n- be an <a href=\"#OpConstant\"><strong>OpConstant</strong></a> when indexing into a structure.",
    "DescriptionPlain": "OpAccessChain\n\nCreate a pointer into a composite object that can be used with OpLoad and OpStore. \n\n Result Type must be an OpTypePointer. Its Type operand must be the type reached by walking the Base&#8217;s type hierarchy down to the last provided index in Indexes, and its Storage Class operand must be the same as the Storage Class of Base.\n\nBase must be a pointer, pointing to the base of a composite object.\n\nIndexes walk the type hierarchy to the desired depth, potentially down to scalar granularity. The first index in Indexes will select the top-level member/element/component/element of the base composite. All composite constituents use zero-based numbering, as described by their OpType&#8230; instruction. The second index will apply similarly to that result, and so on. Once any non-composite type is reached, there must be no remaining (unused) indexes. Each of the Indexes must:\n- be a scalar integer type,\n- be an OpConstant when indexing into a structure.",
    "Category": "Memory",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 65,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Indexes",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpInBoundsAccessChain",
    "Description": "<a id=\"OpInBoundsAccessChain\"></a><strong>OpInBoundsAccessChain</strong><br />\n<br />\nHas the same semantics as <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a>, with the addition that the resulting pointer is known to point within the base object.",
    "DescriptionPlain": "OpInBoundsAccessChain\n\nHas the same semantics as OpAccessChain, with the addition that the resulting pointer is known to point within the base object.",
    "Category": "Memory",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 66,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Indexes",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpPtrAccessChain",
    "Description": "<a id=\"OpPtrAccessChain\"></a><strong>OpPtrAccessChain</strong><br />\n<br />\nHas the same semantics as <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a>, with the addition of the <em>Element</em> operand.<br />\n<br />\n<em>Element</em> is used to do the initial dereference of <em>Base</em>: <em>Base</em> is treated as the address of the first element of an array, and the <em>Element</em> element&#8217;s address is computed to be the base for the <em>Indexes</em>, as per <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a>. The type of <em>Base</em> after being dereferenced with <em>Element</em> is still the same as the original type of <em>Base</em>.<br />\n<br />\nNote: If <em>Base</em> is originally typed to be a pointer an array, and the desired operation is to select an element of that array, <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a> should be directly used, as its first <em>Index</em> will select the array element.",
    "DescriptionPlain": "OpPtrAccessChain\n\nHas the same semantics as OpAccessChain, with the addition of the Element operand.\n\nElement is used to do the initial dereference of Base: Base is treated as the address of the first element of an array, and the Element element&#8217;s address is computed to be the base for the Indexes, as per OpAccessChain. The type of Base after being dereferenced with Element is still the same as the original type of Base.\n\nNote: If Base is originally typed to be a pointer an array, and the desired operation is to select an element of that array, OpAccessChain should be directly used, as its first Index will select the array element.",
    "Category": "Memory",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 67,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Element",
        "Type": "ID"
      },
      {
        "Name": "Indexes",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpArrayLength",
    "Description": "<a id=\"OpArrayLength\"></a><strong>OpArrayLength</strong><br />\n<br />\nLength of a run-time array.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeInt\">OpTypeInt</a> with 32-bit <em>Width</em> and 0 <em>Signedness</em>.<br />\n<br />\n<em>Structure</em> must have a type of <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> whose last member is a run-time array.<br />\n<br />\n<em>Array member</em> is the last member number of <em>Structure</em> and must have a type from <a href=\"#OpTypeRuntimeArray\"><strong>OpTypeRuntimeArray</strong></a>.",
    "DescriptionPlain": "OpArrayLength\n\nLength of a run-time array.\n\nResult Type must be an OpTypeInt with 32-bit Width and 0 Signedness.\n\nStructure must have a type of OpTypeStruct whose last member is a run-time array.\n\nArray member is the last member number of Structure and must have a type from OpTypeRuntimeArray.",
    "Category": "Memory",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 68,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Structure",
        "Type": "ID"
      },
      {
        "Name": "ArrayMember",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpGenericPtrMemSemantics",
    "Description": "<a id=\"OpGenericPtrMemSemantics\"></a><strong>OpGenericPtrMemSemantics</strong><br />\n<br />\nResult is a valid <a href=\"#Memory_Semantics_-id-\"><strong>Memory Semantics</strong></a> which includes mask bits set for the Storage Class for the specific (non-Generic) Storage Class of <em>Pointer</em>. <br />\n<br />\n<em>Pointer</em> must point to <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeInt\">OpTypeInt</a> with 32-bit <em>Width</em> and 0 <em>Signedness</em>.",
    "DescriptionPlain": "OpGenericPtrMemSemantics\n\nResult is a valid Memory Semantics which includes mask bits set for the Storage Class for the specific (non-Generic) Storage Class of Pointer. \n\nPointer must point to Generic Storage Class.\n\nResult Type must be an OpTypeInt with 32-bit Width and 0 Signedness.",
    "Category": "Memory",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 69,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpInBoundsPtrAccessChain",
    "Description": "<a id=\"OpInBoundsPtrAccessChain\"></a><strong>OpInBoundsPtrAccessChain</strong><br />\n<br />\nHas the same semantics as <a href=\"#OpPtrAccessChain\"><strong>OpPtrAccessChain</strong></a>, with the addition that the resulting pointer is known to point within the base object.",
    "DescriptionPlain": "OpInBoundsPtrAccessChain\n\nHas the same semantics as OpPtrAccessChain, with the addition that the resulting pointer is known to point within the base object.",
    "Category": "Memory",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 70,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Element",
        "Type": "ID"
      },
      {
        "Name": "Indexes",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpFunction",
    "Description": "<a id=\"OpFunction\"></a><strong>OpFunction</strong><br />\n<br />\nAdd a function.  This instruction must be immediately followed by one <a href=\"#OpFunctionParameter\"><strong>OpFunctionParameter</strong></a> instruction per each formal parameter of this function. This function&#8217;s body or declaration will terminate with the next <a href=\"#OpFunctionEnd\"><strong>OpFunctionEnd</strong></a> instruction.<br />\n<br />\nThe <em>Result &lt;id&gt;</em> cannot be used generally by other instructions. It can only be used by <a href=\"#OpFunctionCall\"><strong>OpFunctionCall</strong></a>,  <a href=\"#OpEntryPoint\"><strong>OpEntryPoint</strong></a>, and decoration instructions.<br />\n<br />\n<em>Result Type</em> must be the same as the <em>Return Type</em> declared in <em>Function Type</em>.<br />\n<br />\n<em>Function Type</em> is the result of an <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a>, which declares the types of the return value and parameters of the function.",
    "DescriptionPlain": "OpFunction\n\nAdd a function.  This instruction must be immediately followed by one OpFunctionParameter instruction per each formal parameter of this function. This function&#8217;s body or declaration will terminate with the next OpFunctionEnd instruction.\n\nThe Result &lt;id&gt; cannot be used generally by other instructions. It can only be used by OpFunctionCall,  OpEntryPoint, and decoration instructions.\n\nResult Type must be the same as the Return Type declared in Function Type.\n\nFunction Type is the result of an OpTypeFunction, which declares the types of the return value and parameters of the function.",
    "Category": "Function",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 54,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "FunctionControl",
        "Type": "FunctionControl"
      },
      {
        "Name": "FunctionType",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFunctionParameter",
    "Description": "<a id=\"OpFunctionParameter\"></a><strong>OpFunctionParameter</strong><br />\n<br />\nDeclare a formal parameter of the current function.<br />\n<br />\n<em>Result Type</em> is the type of the parameter.<br />\n<br />\nThis instruction must immediately follow an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> or <a href=\"#OpFunctionParameter\"><strong>OpFunctionParameter</strong></a> instruction. The order of contiguous <strong>OpFunctionParameter</strong> instructions is the same order arguments will be listed in an <a href=\"#OpFunctionCall\"><strong>OpFunctionCall</strong></a> instruction to this function. It is also the same order in which <em>Parameter Type</em> operands are listed in the <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> of the <em>Function Type</em> operand for this function&#8217;s <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.",
    "DescriptionPlain": "OpFunctionParameter\n\nDeclare a formal parameter of the current function.\n\nResult Type is the type of the parameter.\n\nThis instruction must immediately follow an OpFunction or OpFunctionParameter instruction. The order of contiguous OpFunctionParameter instructions is the same order arguments will be listed in an OpFunctionCall instruction to this function. It is also the same order in which Parameter Type operands are listed in the OpTypeFunction of the Function Type operand for this function&#8217;s OpFunction instruction.",
    "Category": "Function",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 55,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFunctionEnd",
    "Description": "<a id=\"OpFunctionEnd\"></a><strong>OpFunctionEnd</strong><br />\n<br />\nLast instruction of a function.",
    "DescriptionPlain": "OpFunctionEnd\n\nLast instruction of a function.",
    "Category": "Function",
    "Capabilities": [],
    "WordCount": "1",
    "WordCountFix": 1,
    "OpCode": 56,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": []
  },
  {
    "Name": "OpFunctionCall",
    "Description": "<a id=\"OpFunctionCall\"></a><strong>OpFunctionCall</strong><br />\n<br />\nCall a function.<br />\n<br />\n<em>Result Type</em> is the type of the return value of the function. It must be the same as the <em>Return Type</em> operand of the <em>Function Type</em> operand of the <em>Function</em> operand.<br />\n<br />\n<em>Function</em> is an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.  This could be a forward reference.<br />\n<br />\n<em>Argument N</em> is the object to copy to parameter <em>N</em> of <em>Function</em>.<br />\n<br />\n<strong>Note:</strong> A forward call is possible because there is no missing type information: <em>Result Type</em> must match the <em>Return Type</em> of the function, and the calling argument types must match the formal parameter types.",
    "DescriptionPlain": "OpFunctionCall\n\nCall a function.\n\nResult Type is the type of the return value of the function. It must be the same as the Return Type operand of the Function Type operand of the Function operand.\n\nFunction is an OpFunction instruction.  This could be a forward reference.\n\nArgument N is the object to copy to parameter N of Function.\n\nNote: A forward call is possible because there is no missing type information: Result Type must match the Return Type of the function, and the calling argument types must match the formal parameter types.",
    "Category": "Function",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 57,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Function",
        "Type": "ID"
      },
      {
        "Name": "Arguments",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpSampledImage",
    "Description": "<a id=\"OpSampledImage\"></a><strong>OpSampledImage</strong><br />\n<br />\nCreate a <a href=\"#SampledImage\">sampled image</a>, containing both a <a href=\"#Sampler\">sampler</a> and an <a href=\"#ImageTerm\">image</a>.<br />\n<br />\n<em>Result Type</em> must be the <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a> type.<br />\n<br />\n<em>Image</em> is an object whose type is an <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>, whose <em>Sampled</em> operand is 0 or 1, and whose <a href=\"#Dim\"><em>Dim</em></a> operand is not <strong>SubpassData</strong>.<br />\n<br />\n<em>Sampler</em> must be an object whose type is <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.",
    "DescriptionPlain": "OpSampledImage\n\nCreate a sampled image, containing both a sampler and an image.\n\nResult Type must be the OpTypeSampledImage type.\n\nImage is an object whose type is an OpTypeImage, whose Sampled operand is 0 or 1, and whose Dim operand is not SubpassData.\n\nSampler must be an object whose type is OpTypeSampler.",
    "Category": "Image",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 86,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      },
      {
        "Name": "Sampler",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageSampleImplicitLod",
    "Description": "<a id=\"OpImageSampleImplicitLod\"></a><strong>OpImageSampleImplicitLod</strong><br />\n<br />\nSample an image with an implicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "DescriptionPlain": "OpImageSampleImplicitLod\n\nSample an image with an implicit level of detail.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 87,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSampleExplicitLod",
    "Description": "<a id=\"OpImageSampleExplicitLod\"></a><strong>OpImageSampleExplicitLod</strong><br />\n<br />\nSample an image using an explicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. Unless the <strong>Kernel</strong> <a href=\"#Capability\">capability</a> is being used, it must be floating point. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
    "DescriptionPlain": "OpImageSampleExplicitLod\n\nSample an image using an explicit level of detail.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. Unless the Kernel capability is being used, it must be floating point. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
    "Category": "Image",
    "Capabilities": [],
    "WordCount": "7 + variable",
    "WordCountFix": 7,
    "OpCode": 88,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "ImageOperands",
        "Type": "ImageOperands"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSampleDrefImplicitLod",
    "Description": "<a id=\"OpImageSampleDrefImplicitLod\"></a><strong>OpImageSampleDrefImplicitLod</strong><br />\n<br />\nSample an image doing depth-comparison with an implicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "DescriptionPlain": "OpImageSampleDrefImplicitLod\n\nSample an image doing depth-comparison with an implicit level of detail.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6 + variable",
    "WordCountFix": 6,
    "OpCode": 89,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSampleDrefExplicitLod",
    "Description": "<a id=\"OpImageSampleDrefExplicitLod\"></a><strong>OpImageSampleDrefExplicitLod</strong><br />\n<br />\nSample an image doing depth-comparison using an explicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
    "DescriptionPlain": "OpImageSampleDrefExplicitLod\n\nSample an image doing depth-comparison using an explicit level of detail.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8 + variable",
    "WordCountFix": 8,
    "OpCode": 90,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "ImageOperands",
        "Type": "ImageOperands"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSampleProjImplicitLod",
    "Description": "<a id=\"OpImageSampleProjImplicitLod\"></a><strong>OpImageSampleProjImplicitLod</strong><br />\n<br />\nSample an image with with a project coordinate and an implicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. The <a href=\"#Dim\"><em>Dim</em></a> operand of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must be <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>,  and the <em>Arrayed</em> and <em>MS</em> operands must be 0.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector containing (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definition of <em>Sampled Image</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "DescriptionPlain": "OpImageSampleProjImplicitLod\n\nSample an image with with a project coordinate and an implicit level of detail.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\n\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 91,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSampleProjExplicitLod",
    "Description": "<a id=\"OpImageSampleProjExplicitLod\"></a><strong>OpImageSampleProjExplicitLod</strong><br />\n<br />\nSample an image with a project coordinate using an explicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. The <a href=\"#Dim\"><em>Dim</em></a> operand of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must be <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>,  and the <em>Arrayed</em> and <em>MS</em> operands must be 0.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector containing (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definition of <em>Sampled Image</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
    "DescriptionPlain": "OpImageSampleProjExplicitLod\n\nSample an image with a project coordinate using an explicit level of detail.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\n\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7 + variable",
    "WordCountFix": 7,
    "OpCode": 92,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "ImageOperands",
        "Type": "ImageOperands"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSampleProjDrefImplicitLod",
    "Description": "<a id=\"OpImageSampleProjDrefImplicitLod\"></a><strong>OpImageSampleProjDrefImplicitLod</strong><br />\n<br />\nSample an image with a project coordinate, doing depth-comparison, with an implicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. The <a href=\"#Dim\"><em>Dim</em></a> operand of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must be <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>,  and the <em>Arrayed</em> and <em>MS</em> operands must be 0.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector containing (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definition of <em>Sampled Image</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> /<em>q</em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "DescriptionPlain": "OpImageSampleProjDrefImplicitLod\n\nSample an image with a project coordinate, doing depth-comparison, with an implicit level of detail.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\n\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref /q is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6 + variable",
    "WordCountFix": 6,
    "OpCode": 93,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSampleProjDrefExplicitLod",
    "Description": "<a id=\"OpImageSampleProjDrefExplicitLod\"></a><strong>OpImageSampleProjDrefExplicitLod</strong><br />\n<br />\nSample an image with a project coordinate, doing depth-comparison, using an explicit level of detail.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. The <a href=\"#Dim\"><em>Dim</em></a> operand of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must be <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>,  and the <em>Arrayed</em> and <em>MS</em> operands must be 0.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector containing (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definition of <em>Sampled Image</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> /<em>q</em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
    "DescriptionPlain": "OpImageSampleProjDrefExplicitLod\n\nSample an image with a project coordinate, doing depth-comparison, using an explicit level of detail.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\n\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref /q is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8 + variable",
    "WordCountFix": 8,
    "OpCode": 94,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "ImageOperands",
        "Type": "ImageOperands"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageFetch",
    "Description": "<a id=\"OpImageFetch\"></a><strong>OpImageFetch</strong><br />\n<br />\nFetch a single texel from a sampled image.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand cannot be <strong>Cube</strong>, and its <em>Sampled</em> operand must be 1.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageFetch\n\nFetch a single texel from a sampled image.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nImage must be an object whose type is OpTypeImage. Its Dim operand cannot be Cube, and its Sampled operand must be 1.\n\nCoordinate is an integer scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 95,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageGather",
    "Description": "<a id=\"OpImageGather\"></a><strong>OpImageGather</strong><br />\n<br />\nGathers the requested component from four texels.<br />\n<br />\n <em>Result Type</em> must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>). It has one component per gathered texel.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must have a <a href=\"#Dim\"><em>Dim</em></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>Component</em> is the component number that will be gathered from all four texels. It must be 0, 1, 2 or 3.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageGather\n\nGathers the requested component from four texels.\n\n Result Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nComponent is the component number that will be gathered from all four texels. It must be 0, 1, 2 or 3.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6 + variable",
    "WordCountFix": 6,
    "OpCode": 96,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Component",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageDrefGather",
    "Description": "<a id=\"OpImageDrefGather\"></a><strong>OpImageDrefGather</strong><br />\n<br />\nGathers the requested depth-comparison from four texels.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. It has one component per gathered texel.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must have a <a href=\"#Dim\"><em>Dim</em></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageDrefGather\n\nGathers the requested depth-comparison from four texels.\n\n Result Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage. It has one component per gathered texel.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6 + variable",
    "WordCountFix": 6,
    "OpCode": 97,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageRead",
    "Description": "<a id=\"OpImageRead\"></a><strong>OpImageRead</strong><br />\n<br />\nRead a texel from an <a href=\"#ImageTerm\">image</a> without a <a href=\"#Sampler\">sampler</a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its component type must be the same as <em>Sampled Type</em> of the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> with a <em>Sampled</em> operand of 0 or 2. If the <em>Sampled</em> operand is 2, then some <a href=\"#Dim\">dimensions</a> require a <a href=\"#Capability\">capability</a>; e.g., one of <strong>Image1D</strong>, <strong>ImageRect</strong>, <strong>ImageBuffer</strong>, <strong>ImageCubeArray</strong>, or <strong>ImageMSArray</strong>.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing non-normalized texel coordinates (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Image</em>. If the coordinates are outside the image, the memory location that is accessed is undefined.<br />\n<br />\n When the <em>Image</em> <a href=\"#Dim\"><em>Dim</em></a> operand is <strong>SubpassData</strong>, <em>Coordinate</em> is relative to the current fragment location. That is, the integer value (rounded down) of the current fragment&#8217;s window-relative <em>(x, y)</em> coordinate is added to <em>(u, v)</em>.<br />\n<br />\n When the <em>Image</em> <a href=\"#Dim\"><em>Dim</em></a> operand is not <strong>SubpassData</strong>, the <a href=\"#Image_Format\"><em>Image Format</em></a> must not be <strong>Unknown</strong>, unless the <strong>StorageImageReadWithoutFormat</strong> <a href=\"#Capability\">Capability</a> was declared.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageRead\n\nRead a texel from an image without a sampler.\n\n Result Type must be a scalar or vector of floating-point type or integer type.  Its component type must be the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\n\nImage must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2. If the Sampled operand is 2, then some dimensions require a capability; e.g., one of Image1D, ImageRect, ImageBuffer, ImageCubeArray, or ImageMSArray.\n\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] &#8230; [, array layer]) as needed by the definition of Image. If the coordinates are outside the image, the memory location that is accessed is undefined.\n\n When the Image Dim operand is SubpassData, Coordinate is relative to the current fragment location. That is, the integer value (rounded down) of the current fragment&#8217;s window-relative (x, y) coordinate is added to (u, v).\n\n When the Image Dim operand is not SubpassData, the Image Format must not be Unknown, unless the StorageImageReadWithoutFormat Capability was declared.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 98,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageWrite",
    "Description": "<a id=\"OpImageWrite\"></a><strong>OpImageWrite</strong><br />\n<br />\nWrite a texel to an <a href=\"#ImageTerm\">image</a> without a <a href=\"#Sampler\">sampler</a>.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> with a <em>Sampled</em> operand of 0 or 2. If the <em>Sampled</em> operand is 2, then some <a href=\"#Dim\">dimensions</a> require a <a href=\"#Capability\">capability</a>; e.g., one of <strong>Image1D</strong>, <strong>ImageRect</strong>, <strong>ImageBuffer</strong>, <strong>ImageCubeArray</strong>, or <strong>ImageMSArray</strong>. Its <a href=\"#Dim\"><em>Dim</em></a> operand cannot be <strong>SubpassData</strong>.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing non-normalized texel coordinates (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Image</em>. If the coordinates are outside the image, the memory location that is accessed is undefined.<br />\n<br />\n<em>Texel</em> is the data to write. Its component type must be the same as <em>Sampled Type</em> of the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n The <a href=\"#Image_Format\"><em>Image Format</em></a> must not be <strong>Unknown</strong>, unless the <strong>StorageImageWriteWithoutFormat</strong> <a href=\"#Capability\">Capability</a> was declared.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageWrite\n\nWrite a texel to an image without a sampler.\n\nImage must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2. If the Sampled operand is 2, then some dimensions require a capability; e.g., one of Image1D, ImageRect, ImageBuffer, ImageCubeArray, or ImageMSArray. Its Dim operand cannot be SubpassData.\n\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] &#8230; [, array layer]) as needed by the definition of Image. If the coordinates are outside the image, the memory location that is accessed is undefined.\n\nTexel is the data to write. Its component type must be the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\n\n The Image Format must not be Unknown, unless the StorageImageWriteWithoutFormat Capability was declared.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 99,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Image",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Texel",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImage",
    "Description": "<a id=\"OpImage\"></a><strong>OpImage</strong><br />\n<br />\nExtract the image from a sampled image.<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must have type <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a> whose <em>Image Type</em> is the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpImage\n\nExtract the image from a sampled image.\n\nResult Type must be OpTypeImage.\n\nSampled Image must have type OpTypeSampledImage whose Image Type is the same as Result Type.",
    "Category": "Image",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 100,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageQueryFormat",
    "Description": "<a id=\"OpImageQueryFormat\"></a><strong>OpImageQueryFormat</strong><br />\n<br />\nQuery the image format of an image created with an <strong>Unknown</strong> <a href=\"#Image_Format\">Image Format</a>.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The resulting value is an enumerant from <a href=\"#Image_Channel_Data_Type\">Image Channel Data Type</a>.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.",
    "DescriptionPlain": "OpImageQueryFormat\n\nQuery the image format of an image created with an Unknown Image Format.\n\nResult Type must be a scalar integer type. The resulting value is an enumerant from Image Channel Data Type.\n\nImage must be an object whose type is OpTypeImage.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 101,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageQueryOrder",
    "Description": "<a id=\"OpImageQueryOrder\"></a><strong>OpImageQueryOrder</strong><br />\n<br />\nQuery the channel order of an image created with an <strong>Unknown</strong> <a href=\"#Image_Format\">Image Format</a>.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The resulting value is an enumerant from <a href=\"#Image_Channel_Order\">Image Channel Order</a>.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.",
    "DescriptionPlain": "OpImageQueryOrder\n\nQuery the channel order of an image created with an Unknown Image Format.\n\nResult Type must be a scalar integer type. The resulting value is an enumerant from Image Channel Order.\n\nImage must be an object whose type is OpTypeImage.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 102,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageQuerySizeLod",
    "Description": "<a id=\"OpImageQuerySizeLod\"></a><strong>OpImageQuerySizeLod</strong><br />\n<br />\nQuery the dimensions of <em>Image</em> for mipmap level for <em>Level of Detail</em>.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#Integer\">integer type</a> scalar or vector.  The number of components must be<br />\n1 for <strong>1D</strong> <a href=\"#Dim\"><em>Dim</em></a>,<br />\n2 for <strong>2D</strong>, and <strong>Cube</strong> <a href=\"#Dim\"><strong>Dimensionalities</strong></a>,<br />\n3 for <strong>3D</strong> <a href=\"#Dim\"><em>Dim</em></a>,<br />\nplus 1 more if the image type is arrayed. This vector is filled in with (<em>width</em> [, <em>height</em>] [, <em>depth</em>] [, <em>elements</em>]) where <em>elements</em> is the number of layers in an image array, or the number of cubes in a cube-map array.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>, and its <em>MS</em> must be 0. See <a href=\"#OpImageQuerySize\"><strong>OpImageQuerySize</strong></a> for querying image types without level of detail.<br />\n<br />\n<em>Level of Detail</em> is used to compute which mipmap level to query, as described in the API specification.",
    "DescriptionPlain": "OpImageQuerySizeLod\n\nQuery the dimensions of Image for mipmap level for Level of Detail.\n\nResult Type must be an integer type scalar or vector.  The number of components must be\n1 for 1D Dim,\n2 for 2D, and Cube Dimensionalities,\n3 for 3D Dim,\nplus 1 more if the image type is arrayed. This vector is filled in with (width [, height] [, depth] [, elements]) where elements is the number of layers in an image array, or the number of cubes in a cube-map array.\n\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube, and its MS must be 0. See OpImageQuerySize for querying image types without level of detail.\n\nLevel of Detail is used to compute which mipmap level to query, as described in the API specification.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 103,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      },
      {
        "Name": "LevelOfDetail",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageQuerySize",
    "Description": "<a id=\"OpImageQuerySize\"></a><strong>OpImageQuerySize</strong><br />\n<br />\nQuery the dimensions of <em>Image</em>, with no level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#Integer\">integer type</a> scalar or vector.  The number of components must be<br />\n1 for <strong>Buffer</strong> <a href=\"#Dim\"><em>Dim</em></a>,<br />\n2 for <strong>2D</strong> and <strong>Rect</strong> <a href=\"#Dim\"><strong>Dimensionalities</strong></a>,<br />\n3 for <strong>3D</strong> <a href=\"#Dim\"><em>Dim</em></a>,<br />\nplus 1 more if the image type is arrayed. This vector is filled in with (<em>width</em> [, <em>height</em>] [, <em>elements</em>]) where <em>elements</em> is the number of layers in an image array.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>Rect</strong> or <strong>Buffer</strong>, or if its <em>MS</em> is 1, it can be <strong>2D</strong>, or, if its <em>Sampled Type</em> is 0 or 2, it can be <strong>2D</strong> or <strong>3D</strong>. It cannot be an image with level of detail; there is no implicit level-of-detail consumed by this instruction. See <a href=\"#OpImageQuerySizeLod\"><strong>OpImageQuerySizeLod</strong></a> for querying images having level of detail.",
    "DescriptionPlain": "OpImageQuerySize\n\nQuery the dimensions of Image, with no level of detail.\n\nResult Type must be an integer type scalar or vector.  The number of components must be\n1 for Buffer Dim,\n2 for 2D and Rect Dimensionalities,\n3 for 3D Dim,\nplus 1 more if the image type is arrayed. This vector is filled in with (width [, height] [, elements]) where elements is the number of layers in an image array.\n\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of Rect or Buffer, or if its MS is 1, it can be 2D, or, if its Sampled Type is 0 or 2, it can be 2D or 3D. It cannot be an image with level of detail; there is no implicit level-of-detail consumed by this instruction. See OpImageQuerySizeLod for querying images having level of detail.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 104,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageQueryLod",
    "Description": "<a id=\"OpImageQueryLod\"></a><strong>OpImageQueryLod</strong><br />\n<br />\nQuery the mipmap level and the level of detail for a hypothetical sampling of <em>Image</em> at <em>Coordinate</em> using an implicit level of detail.<br />\n<br />\n<em>Result Type</em> must be a two-component <a href=\"#Floating\">floating-point type</a> vector.<br />\nThe first component of the result will contain the mipmap array layer.<br />\nThe second component of the result will contain the implicit level of detail relative to the base level.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; ) as needed by the definition of <em>Sampled Image</em>, not including any array layer index. Unless the <strong>Kernel</strong> <a href=\"#Capability\">capability</a> is being used, it must be floating point.<br />\n<br />\nIf called on an incomplete image, the results are undefined.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "DescriptionPlain": "OpImageQueryLod\n\nQuery the mipmap level and the level of detail for a hypothetical sampling of Image at Coordinate using an implicit level of detail.\n\nResult Type must be a two-component floating-point type vector.\nThe first component of the result will contain the mipmap array layer.\nThe second component of the result will contain the implicit level of detail relative to the base level.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube.\n\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] &#8230; ) as needed by the definition of Sampled Image, not including any array layer index. Unless the Kernel capability is being used, it must be floating point.\n\nIf called on an incomplete image, the results are undefined.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 105,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageQueryLevels",
    "Description": "<a id=\"OpImageQueryLevels\"></a><strong>OpImageQueryLevels</strong><br />\n<br />\nQuery the number of mipmap levels accessible through <em>Image</em>.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The result is the number of mipmap levels, as defined by the API specification.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>.",
    "DescriptionPlain": "OpImageQueryLevels\n\nQuery the number of mipmap levels accessible through Image.\n\nResult Type must be a scalar integer type. The result is the number of mipmap levels, as defined by the API specification.\n\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 106,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageQuerySamples",
    "Description": "<a id=\"OpImageQuerySamples\"></a><strong>OpImageQuerySamples</strong><br />\n<br />\nQuery the number of samples available per texel fetch in a multisample image.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The result is the number of samples.<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand must be one of <strong>2D</strong> and <em>MS</em> of 1.",
    "DescriptionPlain": "OpImageQuerySamples\n\nQuery the number of samples available per texel fetch in a multisample image.\n\nResult Type must be a scalar integer type. The result is the number of samples.\n\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 2D and MS of 1.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 107,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageSparseSampleImplicitLod",
    "Description": "<a id=\"OpImageSparseSampleImplicitLod\"></a><strong>OpImageSparseSampleImplicitLod</strong><br />\n<br />\nSample a sparse image with an implicit level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "DescriptionPlain": "OpImageSparseSampleImplicitLod\n\nSample a sparse image with an implicit level of detail.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 305,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseSampleExplicitLod",
    "Description": "<a id=\"OpImageSparseSampleExplicitLod\"></a><strong>OpImageSparseSampleExplicitLod</strong><br />\n<br />\nSample a sparse image using an explicit level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. Unless the <strong>Kernel</strong> <a href=\"#Capability\">capability</a> is being used, it must be floating point. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
    "DescriptionPlain": "OpImageSparseSampleExplicitLod\n\nSample a sparse image using an explicit level of detail.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. Unless the Kernel capability is being used, it must be floating point. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7 + variable",
    "WordCountFix": 7,
    "OpCode": 306,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "ImageOperands",
        "Type": "ImageOperands"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseSampleDrefImplicitLod",
    "Description": "<a id=\"OpImageSparseSampleDrefImplicitLod\"></a><strong>OpImageSparseSampleDrefImplicitLod</strong><br />\n<br />\nSample a sparse image doing depth-comparison with an implicit level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "DescriptionPlain": "OpImageSparseSampleDrefImplicitLod\n\nSample a sparse image doing depth-comparison with an implicit level of detail.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.\n\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6 + variable",
    "WordCountFix": 6,
    "OpCode": 307,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseSampleDrefExplicitLod",
    "Description": "<a id=\"OpImageSparseSampleDrefExplicitLod\"></a><strong>OpImageSparseSampleDrefExplicitLod</strong><br />\n<br />\nSample a sparse image doing depth-comparison using an explicit level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>. At least one operand setting the level of detail must be present.",
    "DescriptionPlain": "OpImageSparseSampleDrefExplicitLod\n\nSample a sparse image doing depth-comparison using an explicit level of detail.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\n\nSampled Image must be an object whose type is OpTypeSampledImage.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands. At least one operand setting the level of detail must be present.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8 + variable",
    "WordCountFix": 8,
    "OpCode": 308,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "ImageOperands",
        "Type": "ImageOperands"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseSampleProjImplicitLod",
    "Description": "<a id=\"OpImageSparseSampleProjImplicitLod\"></a><strong>OpImageSparseSampleProjImplicitLod</strong><br />\n<br />\nInstruction reserved for future use.  Use of this instruction is invalid.<br />\n<br />\n<span class=\"line-through\">Sample a sparse image with a projective coordinate and an implicit level of detail.</span>",
    "DescriptionPlain": "OpImageSparseSampleProjImplicitLod\n\nInstruction reserved for future use.  Use of this instruction is invalid.\n\nSample a sparse image with a projective coordinate and an implicit level of detail.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 309,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseSampleProjExplicitLod",
    "Description": "<a id=\"OpImageSparseSampleProjExplicitLod\"></a><strong>OpImageSparseSampleProjExplicitLod</strong><br />\n<br />\nInstruction reserved for future use.  Use of this instruction is invalid.<br />\n<br />\n<span class=\"line-through\">Sample a sparse image with a projective coordinate using an explicit level of detail.</span>",
    "DescriptionPlain": "OpImageSparseSampleProjExplicitLod\n\nInstruction reserved for future use.  Use of this instruction is invalid.\n\nSample a sparse image with a projective coordinate using an explicit level of detail.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7 + variable",
    "WordCountFix": 7,
    "OpCode": 310,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "ImageOperands",
        "Type": "ImageOperands"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseSampleProjDrefImplicitLod",
    "Description": "<a id=\"OpImageSparseSampleProjDrefImplicitLod\"></a><strong>OpImageSparseSampleProjDrefImplicitLod</strong><br />\n<br />\nInstruction reserved for future use.  Use of this instruction is invalid.<br />\n<br />\n<span class=\"line-through\">Sample a sparse image with a projective coordinate, doing depth-comparison, with an implicit level of detail.</span>",
    "DescriptionPlain": "OpImageSparseSampleProjDrefImplicitLod\n\nInstruction reserved for future use.  Use of this instruction is invalid.\n\nSample a sparse image with a projective coordinate, doing depth-comparison, with an implicit level of detail.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6 + variable",
    "WordCountFix": 6,
    "OpCode": 311,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseSampleProjDrefExplicitLod",
    "Description": "<a id=\"OpImageSparseSampleProjDrefExplicitLod\"></a><strong>OpImageSparseSampleProjDrefExplicitLod</strong><br />\n<br />\nInstruction reserved for future use.  Use of this instruction is invalid.<br />\n<br />\n<span class=\"line-through\">Sample a sparse image with a projective coordinate, doing depth-comparison, using an explicit level of detail.</span>",
    "DescriptionPlain": "OpImageSparseSampleProjDrefExplicitLod\n\nInstruction reserved for future use.  Use of this instruction is invalid.\n\nSample a sparse image with a projective coordinate, doing depth-comparison, using an explicit level of detail.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8 + variable",
    "WordCountFix": 8,
    "OpCode": 312,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "ImageOperands",
        "Type": "ImageOperands"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseFetch",
    "Description": "<a id=\"OpImageSparseFetch\"></a><strong>OpImageSparseFetch</strong><br />\n<br />\nFetch a single texel from a sampled sparse image.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. Its <a href=\"#Dim\"><em>Dim</em></a> operand cannot be <strong>Cube</strong>.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageSparseFetch\n\nFetch a single texel from a sampled sparse image.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\n\nImage must be an object whose type is OpTypeImage. Its Dim operand cannot be Cube.\n\nCoordinate is an integer scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 313,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseGather",
    "Description": "<a id=\"OpImageSparseGather\"></a><strong>OpImageSparseGather</strong><br />\n<br />\nGathers the requested component from four texels of a sparse image.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a vector of four components of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its components must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that underlying <em>Sampled Type</em> is <strong>OpTypeVoid</strong>). It has one component per gathered texel.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must have a <a href=\"#Dim\"><em>Dim</em></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>Component</em> is the component number that will be gathered from all four texels. It must be 0, 1, 2 or 3.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageSparseGather\n\nGathers the requested component from four texels of a sparse image.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nComponent is the component number that will be gathered from all four texels. It must be 0, 1, 2 or 3.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6 + variable",
    "WordCountFix": 6,
    "OpCode": 314,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Component",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseDrefGather",
    "Description": "<a id=\"OpImageSparseDrefGather\"></a><strong>OpImageSparseDrefGather</strong><br />\n<br />\nGathers the requested depth-comparison from four texels of a sparse image.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>.  It must be the same as <em>Sampled Type</em> of the underlying <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a>. It has one component per gathered texel.<br />\n<br />\n<em>Sampled Image</em> must be an object whose type is <a href=\"#OpTypeSampledImage\"><strong>OpTypeSampledImage</strong></a>. Its <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> must have a <a href=\"#Dim\"><em>Dim</em></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It contains (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Sampled Image</em>.<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageSparseDrefGather\n\nGathers the requested depth-comparison from four texels of a sparse image.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage. It has one component per gathered texel.\n\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\n\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] &#8230; [, array layer]) as needed by the definition of Sampled Image.\n\nDref is the depth-comparison reference value.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6 + variable",
    "WordCountFix": 6,
    "OpCode": 315,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SampledImage",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Dref",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpImageSparseTexelsResident",
    "Description": "<a id=\"OpImageSparseTexelsResident\"></a><strong>OpImageSparseTexelsResident</strong><br />\n<br />\nTranslates a <em>Resident Code</em> into a Boolean. Result is <strong>false</strong> if any of the texels were in uncommitted texture memory, and <strong>true</strong> otherwise.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar. <br />\n<br />\n<em>Resident Code</em> is a value from an <strong>OpImageSparse&#8230;</strong> instruction that returns a resident code.",
    "DescriptionPlain": "OpImageSparseTexelsResident\n\nTranslates a Resident Code into a Boolean. Result is false if any of the texels were in uncommitted texture memory, and true otherwise.\n\n Result Type must be a Boolean type scalar. \n\nResident Code is a value from an OpImageSparse&#8230; instruction that returns a resident code.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 316,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ResidentCode",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpImageSparseRead",
    "Description": "<a id=\"OpImageSparseRead\"></a><strong>OpImageSparseRead</strong><br />\n<br />\nRead a texel from a sparse <a href=\"#ImageTerm\">image</a> without a <a href=\"#Sampler\">sampler</a>.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with two members. The first member&#8217;s type must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It will hold a <em>Residency Code</em> that can be passed to <a href=\"#OpImageSparseTexelsResident\"><strong>OpImageSparseTexelsResident</strong></a>. The second member  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>.  Its component type must be the same as <em>Sampled Type</em> of the <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> (unless that <em>Sampled Type</em> is <strong>OpTypeVoid</strong>).<br />\n<br />\n<em>Image</em> must be an object whose type is <a href=\"#OpTypeImage\"><strong>OpTypeImage</strong></a> with a <em>Sampled</em> operand of 2.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing non-normalized texel coordinates (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definition of <em>Image</em>. If the coordinates are outside the image, the memory location that is accessed is undefined.<br />\n<br />\n The <a href=\"#Image_Format\"><em>Image Format</em></a> must not be <strong>Unknown</strong>, unless the <strong>StorageImageReadWithoutFormat</strong> <a href=\"#Capability\">Capability</a> was declared.<br />\n<br />\n<em>Image Operands</em> encodes what operands follow, as per <a href=\"#Image_Operands\">Image Operands</a>.",
    "DescriptionPlain": "OpImageSparseRead\n\nRead a texel from a sparse image without a sampler.\n\nResult Type must be an OpTypeStruct with two members. The first member&#8217;s type must be an integer type scalar.  It will hold a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar or vector of floating-point type or integer type.  Its component type must be the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\n\nImage must be an object whose type is OpTypeImage with a Sampled operand of 2.\n\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] &#8230; [, array layer]) as needed by the definition of Image. If the coordinates are outside the image, the memory location that is accessed is undefined.\n\n The Image Format must not be Unknown, unless the StorageImageReadWithoutFormat Capability was declared.\n\nImage Operands encodes what operands follow, as per Image Operands.",
    "Category": "Image",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 320,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Image",
        "Type": "ID"
      },
      {
        "Name": "Coordinate",
        "Type": "ID"
      },
      {
        "Name": "Operands",
        "Type": "OptionalImage"
      },
      {
        "Name": "Optionals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpConvertFToU",
    "Description": "<a id=\"OpConvertFToU\"></a><strong>OpConvertFToU</strong><br />\n<br />\nConvert (value preserving) from floating point to unsigned integer, with round toward 0.0.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Float Value</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpConvertFToU\n\nConvert (value preserving) from floating point to unsigned integer, with round toward 0.0.\n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 109,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "FloatValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConvertFToS",
    "Description": "<a id=\"OpConvertFToS\"></a><strong>OpConvertFToS</strong><br />\n<br />\nConvert (value preserving) from floating point to signed integer, with round toward 0.0.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Float Value</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpConvertFToS\n\nConvert (value preserving) from floating point to signed integer, with round toward 0.0.\n\n Result Type must be a scalar or vector of integer type. \n\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 110,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "FloatValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConvertSToF",
    "Description": "<a id=\"OpConvertSToF\"></a><strong>OpConvertSToF</strong><br />\n<br />\nConvert (value preserving) from signed integer to floating point.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Signed Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpConvertSToF\n\nConvert (value preserving) from signed integer to floating point.\n\n Result Type must be a scalar or vector of floating-point type. \n\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 111,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SignedValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConvertUToF",
    "Description": "<a id=\"OpConvertUToF\"></a><strong>OpConvertUToF</strong><br />\n<br />\nConvert (value preserving) from unsigned integer to floating point.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Unsigned Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpConvertUToF\n\nConvert (value preserving) from unsigned integer to floating point.\n\n Result Type must be a scalar or vector of floating-point type. \n\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 112,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "UnsignedValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpUConvert",
    "Description": "<a id=\"OpUConvert\"></a><strong>OpUConvert</strong><br />\n<br />\nConvert (value preserving) unsigned width. This is either a truncate or a zero extend.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Unsigned Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width cannot equal the component width in <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpUConvert\n\nConvert (value preserving) unsigned width. This is either a truncate or a zero extend.\n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width cannot equal the component width in Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 113,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "UnsignedValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSConvert",
    "Description": "<a id=\"OpSConvert\"></a><strong>OpSConvert</strong><br />\n<br />\nConvert (value preserving) signed width.  This is either a truncate or a sign extend.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Signed Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width cannot equal the component width in <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSConvert\n\nConvert (value preserving) signed width.  This is either a truncate or a sign extend.\n\n Result Type must be a scalar or vector of integer type. \n\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width cannot equal the component width in Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 114,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SignedValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFConvert",
    "Description": "<a id=\"OpFConvert\"></a><strong>OpFConvert</strong><br />\n<br />\nConvert (value preserving) floating-point width.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Float Value</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width cannot equal the component width in <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFConvert\n\nConvert (value preserving) floating-point width.\n\n Result Type must be a scalar or vector of floating-point type. \n\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.  The component width cannot equal the component width in Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 115,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "FloatValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpQuantizeToF16",
    "Description": "<a id=\"OpQuantizeToF16\"></a><strong>OpQuantizeToF16</strong><br />\n<br />\nQuantize a floating-point value to what is expressible by a 16-bit floating-point value.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. The component width must be 32 bits.<br />\n<br />\n<em>Value</em> is the value to quantize. The type of <em>Value</em> must be the same as <em>Result Type</em>. <br />\n<br />\n If <em>Value</em> is an infinity, the result is the same infinity. If <em>Value</em> is a NaN, the result is a NaN, but not necessarily the same NaN. If <em>Value</em> is positive with a magnitude too large to represent as a 16-bit floating-point value, the result is positive infinity. If <em>Value</em> is negative with a magnitude too large to represent as a 16-bit floating-point value, the result is negative infinity. If the magnitude of <em>Value</em> is too small to represent as a normalized 16-bit floating-point value, the result is 0.<br />\n<br />\nThe <strong>RelaxedPrecision</strong> <a href=\"#Decoration\">Decoration</a> has no effect on this instruction.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpQuantizeToF16\n\nQuantize a floating-point value to what is expressible by a 16-bit floating-point value.\n\n Result Type must be a scalar or vector of floating-point type. The component width must be 32 bits.\n\nValue is the value to quantize. The type of Value must be the same as Result Type. \n\n If Value is an infinity, the result is the same infinity. If Value is a NaN, the result is a NaN, but not necessarily the same NaN. If Value is positive with a magnitude too large to represent as a 16-bit floating-point value, the result is positive infinity. If Value is negative with a magnitude too large to represent as a 16-bit floating-point value, the result is negative infinity. If the magnitude of Value is too small to represent as a normalized 16-bit floating-point value, the result is 0.\n\nThe RelaxedPrecision Decoration has no effect on this instruction.\n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 116,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConvertPtrToU",
    "Description": "<a id=\"OpConvertPtrToU\"></a><strong>OpConvertPtrToU</strong><br />\n<br />\nConvert a pointer to an unsigned integer type. A <em>Result Type</em> width larger than the width of <em>Pointer</em> will zero extend. A <em>Result Type</em> smaller than the width of <em>Pointer</em> will truncate. For same-width source and result, this is the same as <a href=\"#OpBitcast\"><strong>OpBitcast</strong></a>. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0.",
    "DescriptionPlain": "OpConvertPtrToU\n\nConvert a pointer to an unsigned integer type. A Result Type width larger than the width of Pointer will zero extend. A Result Type smaller than the width of Pointer will truncate. For same-width source and result, this is the same as OpBitcast. \n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0.",
    "Category": "Conversion",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 117,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSatConvertSToU",
    "Description": "<a id=\"OpSatConvertSToU\"></a><strong>OpSatConvertSToU</strong><br />\n<br />\nConvert a signed integer to unsigned integer. Converted values outside the representable range of <em>Result Type</em> are clamped to the nearest representable value of <em>Result Type</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Signed Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSatConvertSToU\n\nConvert a signed integer to unsigned integer. Converted values outside the representable range of Result Type are clamped to the nearest representable value of Result Type.\n\n Result Type must be a scalar or vector of integer type. \n\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 118,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SignedValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSatConvertUToS",
    "Description": "<a id=\"OpSatConvertUToS\"></a><strong>OpSatConvertUToS</strong><br />\n<br />\nConvert an unsigned integer to signed integer.  Converted values outside the representable range of <em>Result Type</em> are clamped to the nearest representable value of <em>Result Type</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Unsigned Value</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSatConvertUToS\n\nConvert an unsigned integer to signed integer.  Converted values outside the representable range of Result Type are clamped to the nearest representable value of Result Type.\n\n Result Type must be a scalar or vector of integer type. \n\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "Conversion",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 119,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "UnsignedValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConvertUToPtr",
    "Description": "<a id=\"OpConvertUToPtr\"></a><strong>OpConvertUToPtr</strong><br />\n<br />\nConvert an integer to pointer. A <em>Result Type</em> width smaller than the width of <em>Integer Value</em> pointer will truncate. A <em>Result Type</em> width larger than the width of <em>Integer Value</em> pointer will zero extend. <br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. For same-width source and result, this is the same as <a href=\"#OpBitcast\"><strong>OpBitcast</strong></a>.",
    "DescriptionPlain": "OpConvertUToPtr\n\nConvert an integer to pointer. A Result Type width smaller than the width of Integer Value pointer will truncate. A Result Type width larger than the width of Integer Value pointer will zero extend. \n\n Result Type must be an OpTypePointer. For same-width source and result, this is the same as OpBitcast.",
    "Category": "Conversion",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 120,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "IntegerValue",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpPtrCastToGeneric",
    "Description": "<a id=\"OpPtrCastToGeneric\"></a><strong>OpPtrCastToGeneric</strong><br />\n<br />\nConvert a pointer&#8217;s Storage Class to <strong>Generic</strong>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <a href=\"#Storage_Class\">Storage Class</a> must be <strong>Generic</strong>.<br />\n<br />\n<em>Pointer</em> must point to the <strong>Workgroup</strong>, <strong>CrossWorkgroup</strong>, or <strong>Function</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Result Type</em> and <em>Pointer</em> must point to the same type.",
    "DescriptionPlain": "OpPtrCastToGeneric\n\nConvert a pointer&#8217;s Storage Class to Generic.\n\n Result Type must be an OpTypePointer. Its Storage Class must be Generic.\n\nPointer must point to the Workgroup, CrossWorkgroup, or Function Storage Class.\n\nResult Type and Pointer must point to the same type.",
    "Category": "Conversion",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 121,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGenericCastToPtr",
    "Description": "<a id=\"OpGenericCastToPtr\"></a><strong>OpGenericCastToPtr</strong><br />\n<br />\nConvert a pointer&#8217;s Storage Class to a non-<strong>Generic</strong> class.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <a href=\"#Storage_Class\">Storage Class</a> must be <strong>Workgroup</strong>, <strong>CrossWorkgroup</strong>, or <strong>Function</strong>.<br />\n<br />\n<em>Pointer</em> must point to the <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Result Type</em> and <em>Pointer</em> must point to the same type.",
    "DescriptionPlain": "OpGenericCastToPtr\n\nConvert a pointer&#8217;s Storage Class to a non-Generic class.\n\n Result Type must be an OpTypePointer. Its Storage Class must be Workgroup, CrossWorkgroup, or Function.\n\nPointer must point to the Generic Storage Class.\n\nResult Type and Pointer must point to the same type.",
    "Category": "Conversion",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 122,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGenericCastToPtrExplicit",
    "Description": "<a id=\"OpGenericCastToPtrExplicit\"></a><strong>OpGenericCastToPtrExplicit</strong><br />\n<br />\nAttempts to explicitly convert <em>Pointer</em> to <em>Storage</em> storage-class pointer value. <br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>. Its <a href=\"#Storage_Class\">Storage Class</a> must be <em>Storage</em>.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose <em>Type</em> is the same as the <em>Type</em> of <em>Result Type</em>.<em>Pointer</em> must point to the <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>. If the cast fails, the instruction result is an <a href=\"#OpConstantNull\"><strong>OpConstantNull</strong></a> pointer in the <em>Storage</em> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Storage</em> must be one of the following literal values from <a href=\"#Storage_Class\">Storage Class</a>: <strong>Workgroup</strong>, <strong>CrossWorkgroup</strong>, or <strong>Function</strong>.",
    "DescriptionPlain": "OpGenericCastToPtrExplicit\n\nAttempts to explicitly convert Pointer to Storage storage-class pointer value. \n\n Result Type must be an OpTypePointer. Its Storage Class must be Storage.\n\nPointer must have a type of OpTypePointer whose Type is the same as the Type of Result Type.Pointer must point to the Generic Storage Class. If the cast fails, the instruction result is an OpConstantNull pointer in the Storage Storage Class.\n\nStorage must be one of the following literal values from Storage Class: Workgroup, CrossWorkgroup, or Function.",
    "Category": "Conversion",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 123,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "Storage",
        "Type": "StorageClass"
      }
    ]
  },
  {
    "Name": "OpBitcast",
    "Description": "<a id=\"OpBitcast\"></a><strong>OpBitcast</strong><br />\n<br />\nBit pattern-preserving type conversion.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>, or a scalar or vector of <a href=\"#Numerical\"><em>numerical-type</em></a>.<br />\n<br />\n<em>Operand</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>, or a scalar or vector of <a href=\"#Numerical\"><em>numerical-type</em></a>. It must be a different type than <em>Result Type</em>.<br />\n<br />\n If <em>Result Type</em> is a pointer, <em>Operand</em> must be a pointer or integer scalar. If <em>Operand</em> is a pointer, <em>Result Type</em> must be a pointer or integer scalar.<br />\n<br />\nIf <em>Result Type</em> has the same number of components as <em>Operand</em>, they must also have the same component width, and results are computed per component.<br />\n<br />\nIf <em>Result Type</em> has a different number of components than <em>Operand</em>, the total number of bits in <em>Result Type</em> must equal the total number of bits in <em>Operand</em>. Let <em>L</em> be the type, either <em>Result Type</em> or <em>Operand&#8217;s</em> type, that has the larger number of components. Let <em>S</em> be the other type, with the smaller number of components. The number of components in <em>L</em> must be an integer multiple of the number of components in <em>S</em>. The first component (that is, the only or lowest-numbered component) of <em>S</em> maps to the first components of <em>L</em>, and so on,  up to the last component of <em>S</em> mapping to the last components of <em>L</em>. Within this mapping, any single component of <em>S</em> (mapping to multiple components of <em>L</em>) maps its lower-ordered bits to the lower-numbered components of <em>L</em>.",
    "DescriptionPlain": "OpBitcast\n\nBit pattern-preserving type conversion.\n\nResult Type must be an OpTypePointer, or a scalar or vector of numerical-type.\n\nOperand must have a type of OpTypePointer, or a scalar or vector of numerical-type. It must be a different type than Result Type.\n\n If Result Type is a pointer, Operand must be a pointer or integer scalar. If Operand is a pointer, Result Type must be a pointer or integer scalar.\n\nIf Result Type has the same number of components as Operand, they must also have the same component width, and results are computed per component.\n\nIf Result Type has a different number of components than Operand, the total number of bits in Result Type must equal the total number of bits in Operand. Let L be the type, either Result Type or Operand&#8217;s type, that has the larger number of components. Let S be the other type, with the smaller number of components. The number of components in L must be an integer multiple of the number of components in S. The first component (that is, the only or lowest-numbered component) of S maps to the first components of L, and so on,  up to the last component of S mapping to the last components of L. Within this mapping, any single component of S (mapping to multiple components of L) maps its lower-ordered bits to the lower-numbered components of L.",
    "Category": "Conversion",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 124,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpVectorExtractDynamic",
    "Description": "<a id=\"OpVectorExtractDynamic\"></a><strong>OpVectorExtractDynamic</strong><br />\n<br />\nExtract a single, dynamically selected, component of a vector.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Scalar\">scalar</a> type.<br />\n<br />\n<em>Vector</em> must have a type <a href=\"#OpTypeVector\"><strong>OpTypeVector</strong></a> whose <em>Component Type</em> is <em>Result Type</em>.<br />\n<br />\n<em>Index</em> must be a scalar <a href=\"#Integer\">integer</a> 0-based index of which component of <em>Vector</em> to extract.<br />\n<br />\nThe value read is undefined if <em>Index&#8217;s</em> value is less than zero or greater than or equal to the number of components in <em>Vector</em>.",
    "DescriptionPlain": "OpVectorExtractDynamic\n\nExtract a single, dynamically selected, component of a vector.\n\nResult Type must be a scalar type.\n\nVector must have a type OpTypeVector whose Component Type is Result Type.\n\nIndex must be a scalar integer 0-based index of which component of Vector to extract.\n\nThe value read is undefined if Index&#8217;s value is less than zero or greater than or equal to the number of components in Vector.",
    "Category": "Composite",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 77,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector",
        "Type": "ID"
      },
      {
        "Name": "Index",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpVectorInsertDynamic",
    "Description": "<a id=\"OpVectorInsertDynamic\"></a><strong>OpVectorInsertDynamic</strong><br />\n<br />\nMake a copy of a vector, with a single, variably selected, component modified.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeVector\"><strong>OpTypeVector</strong></a>.<br />\n<br />\n<em>Vector</em> must have the same type as <em>Result Type</em> and is the vector that the non-written components will be copied from.<br />\n<br />\n<em>Component</em> is the value that will be supplied for the component selected by <em>Index</em>. It must have the same type as the type of components in <em>Result Type</em>.<br />\n<br />\n<em>Index</em> must be a scalar <a href=\"#Integer\">integer</a> 0-based index of which component to modify.<br />\n<br />\nWhat is written is undefined if <em>Index&#8217;s</em> value is less than zero or greater than or equal to the number of components in <em>Vector</em>.",
    "DescriptionPlain": "OpVectorInsertDynamic\n\nMake a copy of a vector, with a single, variably selected, component modified.\n\nResult Type must be an OpTypeVector.\n\nVector must have the same type as Result Type and is the vector that the non-written components will be copied from.\n\nComponent is the value that will be supplied for the component selected by Index. It must have the same type as the type of components in Result Type.\n\nIndex must be a scalar integer 0-based index of which component to modify.\n\nWhat is written is undefined if Index&#8217;s value is less than zero or greater than or equal to the number of components in Vector.",
    "Category": "Composite",
    "Capabilities": [],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 78,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector",
        "Type": "ID"
      },
      {
        "Name": "Component",
        "Type": "ID"
      },
      {
        "Name": "Index",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpVectorShuffle",
    "Description": "<a id=\"OpVectorShuffle\"></a><strong>OpVectorShuffle</strong><br />\n<br />\nSelect arbitrary components from two vectors to make a new vector.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeVector\"><strong>OpTypeVector</strong></a>. The number of components in <em>Result Type</em> must be the same as the number of <em>Component</em> operands.<br />\n<br />\n<em>Vector 1</em> and <em>Vector 2</em> must both have vector types, with the same <em>Component Type</em> as <em>Result Type</em>. They do not have to have the same number of components as <em>Result Type</em> or with each other. They are logically concatenated, forming a single vector with <em>Vector 1&#8217;s</em> components appearing before <em>Vector 2&#8217;s</em>. The components of this logical vector are logically numbered with a single consecutive set of numbers from 0 to <em>N</em> - 1, where <em>N</em> is the total number of components.<br />\n<br />\n<em>Components</em> are these logical numbers (see above), selecting which of the logically numbered components form the result. They can select the components in any order and can repeat components. The first component of the result is selected by the first <em>Component</em> operand,  the second component of the result is selected by the second <em>Component</em> operand, etc. A <em>Component literal</em> may also be FFFFFFFF, which means the corresponding result component has no source and is undefined. All <em>Component literals</em> must either be FFFFFFFF or in [0, <em>N</em> - 1] (<a href=\"#Inclusive\">inclusive</a>).<br />\n<br />\n<strong>Note:</strong> A vector &#8220;swizzle&#8221; can be done by using the vector for both <em>Vector</em> operands, or using an <a href=\"#OpUndef\"><strong>OpUndef</strong></a> for one of the <em>Vector</em> operands.",
    "DescriptionPlain": "OpVectorShuffle\n\nSelect arbitrary components from two vectors to make a new vector.\n\nResult Type must be an OpTypeVector. The number of components in Result Type must be the same as the number of Component operands.\n\nVector 1 and Vector 2 must both have vector types, with the same Component Type as Result Type. They do not have to have the same number of components as Result Type or with each other. They are logically concatenated, forming a single vector with Vector 1&#8217;s components appearing before Vector 2&#8217;s. The components of this logical vector are logically numbered with a single consecutive set of numbers from 0 to N - 1, where N is the total number of components.\n\nComponents are these logical numbers (see above), selecting which of the logically numbered components form the result. They can select the components in any order and can repeat components. The first component of the result is selected by the first Component operand,  the second component of the result is selected by the second Component operand, etc. A Component literal may also be FFFFFFFF, which means the corresponding result component has no source and is undefined. All Component literals must either be FFFFFFFF or in [0, N - 1] (inclusive).\n\nNote: A vector &#8220;swizzle&#8221; can be done by using the vector for both Vector operands, or using an OpUndef for one of the Vector operands.",
    "Category": "Composite",
    "Capabilities": [],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 79,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector1",
        "Type": "ID"
      },
      {
        "Name": "Vector2",
        "Type": "ID"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpCompositeConstruct",
    "Description": "<a id=\"OpCompositeConstruct\"></a><strong>OpCompositeConstruct</strong><br />\n<br />\nConstruct a new <a href=\"#CompositeType\"><em>composite</em></a> object from a set of constituent objects that will fully form it.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#CompositeType\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the operands, with one exception. The exception is that for constructing a vector, the operands may also be vectors with the same component type as the <em>Result Type</em> component type. When constructing a vector, the total number of components in all the operands must equal the number of components in <em>Result Type</em>.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result, with one exception. The exception is that for constructing a vector, a contiguous subset of the scalars consumed can be represented by a vector operand instead. The <em>Constituents</em> must appear in the order needed by the definition of the type of the result. When constructing a vector, there must be at least two <em>Constituent</em> operands.",
    "DescriptionPlain": "OpCompositeConstruct\n\nConstruct a new composite object from a set of constituent objects that will fully form it.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the operands, with one exception. The exception is that for constructing a vector, the operands may also be vectors with the same component type as the Result Type component type. When constructing a vector, the total number of components in all the operands must equal the number of components in Result Type.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result, with one exception. The exception is that for constructing a vector, a contiguous subset of the scalars consumed can be represented by a vector operand instead. The Constituents must appear in the order needed by the definition of the type of the result. When constructing a vector, there must be at least two Constituent operands.",
    "Category": "Composite",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 80,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Constituents",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpCompositeExtract",
    "Description": "<a id=\"OpCompositeExtract\"></a><strong>OpCompositeExtract</strong><br />\n<br />\nExtract a part of a <a href=\"#CompositeType\"><em>composite</em></a> object. <br />\n<br />\n<em>Result Type</em> must be the type of object selected by the last provided index.  The instruction result is the extracted object.<br />\n<br />\n<em>Composite</em> is the composite to extract from.<br />\n<br />\n<em>Indexes</em> walk the type hierarchy, potentially down to component granularity, to select the part to extract. All indexes must be in bounds.  All composite constituents use zero-based numbering, as described by their <strong>OpType&#8230;</strong> instruction.",
    "DescriptionPlain": "OpCompositeExtract\n\nExtract a part of a composite object. \n\nResult Type must be the type of object selected by the last provided index.  The instruction result is the extracted object.\n\nComposite is the composite to extract from.\n\nIndexes walk the type hierarchy, potentially down to component granularity, to select the part to extract. All indexes must be in bounds.  All composite constituents use zero-based numbering, as described by their OpType&#8230; instruction.",
    "Category": "Composite",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 81,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Composite",
        "Type": "ID"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpCompositeInsert",
    "Description": "<a id=\"OpCompositeInsert\"></a><strong>OpCompositeInsert</strong><br />\n<br />\nMake a copy of a <a href=\"#CompositeType\"><em>composite</em></a> object, while modifying one part of it.<br />\n<br />\n<em>Result Type</em> must be the same type as <em>Composite</em>.<br />\n<br />\n<em>Object</em> is the object to use as the modified part.<br />\n<br />\n<em>Composite</em> is the composite to copy all but the modified part from.<br />\n<br />\n<em>Indexes</em> walk the type hierarchy of <em>Composite</em> to the desired depth, potentially down to component granularity, to select the part to modify. All indexes must be in bounds. All composite constituents use zero-based numbering, as described by their <strong>OpType&#8230;</strong> instruction. The type of the part selected to modify must match the type of <em>Object</em>.",
    "DescriptionPlain": "OpCompositeInsert\n\nMake a copy of a composite object, while modifying one part of it.\n\nResult Type must be the same type as Composite.\n\nObject is the object to use as the modified part.\n\nComposite is the composite to copy all but the modified part from.\n\nIndexes walk the type hierarchy of Composite to the desired depth, potentially down to component granularity, to select the part to modify. All indexes must be in bounds. All composite constituents use zero-based numbering, as described by their OpType&#8230; instruction. The type of the part selected to modify must match the type of Object.",
    "Category": "Composite",
    "Capabilities": [],
    "WordCount": "5 + variable",
    "WordCountFix": 5,
    "OpCode": 82,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Object",
        "Type": "ID"
      },
      {
        "Name": "Composite",
        "Type": "ID"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpCopyObject",
    "Description": "<a id=\"OpCopyObject\"></a><strong>OpCopyObject</strong><br />\n<br />\nMake a copy of <em>Operand</em>. There are no dereferences involved.<br />\n<br />\n<em>Result Type</em> must match <em>Operand</em> type.  There are no other restrictions on the types.",
    "DescriptionPlain": "OpCopyObject\n\nMake a copy of Operand. There are no dereferences involved.\n\nResult Type must match Operand type.  There are no other restrictions on the types.",
    "Category": "Composite",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 83,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpTranspose",
    "Description": "<a id=\"OpTranspose\"></a><strong>OpTranspose</strong><br />\n<br />\nTranspose a matrix.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a>, where the number of columns and the column size is the reverse of those of the type of <em>Matrix</em>.<br />\n<br />\n<em>Matrix</em> must have of type of <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a>.",
    "DescriptionPlain": "OpTranspose\n\nTranspose a matrix.\n\nResult Type must be an OpTypeMatrix, where the number of columns and the column size is the reverse of those of the type of Matrix.\n\nMatrix must have of type of OpTypeMatrix.",
    "Category": "Composite",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 84,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Matrix",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSNegate",
    "Description": "<a id=\"OpSNegate\"></a><strong>OpSNegate</strong><br />\n<br />\nSigned-integer subtract of <em>Operand</em> from zero.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n <em>Operand&#8217;s</em> type  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width must equal the component width in <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSNegate\n\nSigned-integer subtract of Operand from zero.\n\n Result Type must be a scalar or vector of integer type. \n\n Operand&#8217;s type  must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must equal the component width in Result Type. \n\n Results are computed per component.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 126,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFNegate",
    "Description": "<a id=\"OpFNegate\"></a><strong>OpFNegate</strong><br />\n<br />\nFloating-point subtract of <em>Operand</em> from zero.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>Operand</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFNegate\n\nFloating-point subtract of Operand from zero.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of Operand must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 127,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIAdd",
    "Description": "<a id=\"OpIAdd\"></a><strong>OpIAdd</strong><br />\n<br />\nInteger addition of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpIAdd\n\nInteger addition of Operand 1 and Operand 2.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 128,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFAdd",
    "Description": "<a id=\"OpFAdd\"></a><strong>OpFAdd</strong><br />\n<br />\nFloating-point addition of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFAdd\n\nFloating-point addition of Operand 1 and Operand 2.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 129,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpISub",
    "Description": "<a id=\"OpISub\"></a><strong>OpISub</strong><br />\n<br />\nInteger subtraction of <em>Operand 2</em> from <em>Operand 1</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpISub\n\nInteger subtraction of Operand 2 from Operand 1.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 130,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFSub",
    "Description": "<a id=\"OpFSub\"></a><strong>OpFSub</strong><br />\n<br />\nFloating-point subtraction of <em>Operand 2</em> from <em>Operand 1</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFSub\n\nFloating-point subtraction of Operand 2 from Operand 1.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 131,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIMul",
    "Description": "<a id=\"OpIMul\"></a><strong>OpIMul</strong><br />\n<br />\nInteger multiplication of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpIMul\n\nInteger multiplication of Operand 1 and Operand 2.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 132,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFMul",
    "Description": "<a id=\"OpFMul\"></a><strong>OpFMul</strong><br />\n<br />\nFloating-point multiplication of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFMul\n\nFloating-point multiplication of Operand 1 and Operand 2.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 133,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpUDiv",
    "Description": "<a id=\"OpUDiv\"></a><strong>OpUDiv</strong><br />\n<br />\nUnsigned-integer division of <em>Operand 1</em> divided by <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
    "DescriptionPlain": "OpUDiv\n\nUnsigned-integer division of Operand 1 divided by Operand 2.\n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 134,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSDiv",
    "Description": "<a id=\"OpSDiv\"></a><strong>OpSDiv</strong><br />\n<br />\nSigned-integer division of <em>Operand 1</em> divided by <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
    "DescriptionPlain": "OpSDiv\n\nSigned-integer division of Operand 1 divided by Operand 2.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 135,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFDiv",
    "Description": "<a id=\"OpFDiv\"></a><strong>OpFDiv</strong><br />\n<br />\nFloating-point division of <em>Operand 1</em> divided by <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
    "DescriptionPlain": "OpFDiv\n\nFloating-point division of Operand 1 divided by Operand 2.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 136,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpUMod",
    "Description": "<a id=\"OpUMod\"></a><strong>OpUMod</strong><br />\n<br />\nUnsigned modulo operation of <em>Operand 1</em> modulo <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
    "DescriptionPlain": "OpUMod\n\nUnsigned modulo operation of Operand 1 modulo Operand 2.\n\n Result Type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 137,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSRem",
    "Description": "<a id=\"OpSRem\"></a><strong>OpSRem</strong><br />\n<br />\nSigned remainder operation of <em>Operand 1</em> divided by <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 1</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
    "DescriptionPlain": "OpSRem\n\nSigned remainder operation of Operand 1 divided by Operand 2.  The sign of a non-0 result comes from Operand 1.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 138,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSMod",
    "Description": "<a id=\"OpSMod\"></a><strong>OpSMod</strong><br />\n<br />\nSigned modulo operation of <em>Operand 1</em> modulo <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
    "DescriptionPlain": "OpSMod\n\nSigned modulo operation of Operand 1 modulo Operand 2.  The sign of a non-0 result comes from Operand 2.\n\n Result Type must be a scalar or vector of integer type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 139,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFRem",
    "Description": "<a id=\"OpFRem\"></a><strong>OpFRem</strong><br />\n<br />\nFloating-point remainder operation of <em>Operand 1</em> divided by <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 1</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
    "DescriptionPlain": "OpFRem\n\nFloating-point remainder operation of Operand 1 divided by Operand 2.  The sign of a non-0 result comes from Operand 1.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 140,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFMod",
    "Description": "<a id=\"OpFMod\"></a><strong>OpFMod</strong><br />\n<br />\nFloating-point remainder operation of <em>Operand 1</em> divided by <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The types of <em>Operand 1</em> and <em>Operand 2</em> both must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.  The resulting value is undefined if <em>Operand 2</em> is 0.",
    "DescriptionPlain": "OpFMod\n\nFloating-point remainder operation of Operand 1 divided by Operand 2.  The sign of a non-0 result comes from Operand 2.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The types of Operand 1 and Operand 2 both must be the same as Result Type. \n\n Results are computed per component.  The resulting value is undefined if Operand 2 is 0.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 141,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpVectorTimesScalar",
    "Description": "<a id=\"OpVectorTimesScalar\"></a><strong>OpVectorTimesScalar</strong><br />\n<br />\nScale a floating-point vector.<br />\n<br />\n <em>Result Type</em> must be a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>Vector</em> must be the same as <em>Result Type</em>. Each component of <em>Vector</em> is multiplied by <em>Scalar</em>.<br />\n<br />\n<em>Scalar</em> must have the same type as the <em>Component Type</em> in <em>Result Type</em>.",
    "DescriptionPlain": "OpVectorTimesScalar\n\nScale a floating-point vector.\n\n Result Type must be a vector of floating-point type. \n\n The type of Vector must be the same as Result Type. Each component of Vector is multiplied by Scalar.\n\nScalar must have the same type as the Component Type in Result Type.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 142,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector",
        "Type": "ID"
      },
      {
        "Name": "Scalar",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpMatrixTimesScalar",
    "Description": "<a id=\"OpMatrixTimesScalar\"></a><strong>OpMatrixTimesScalar</strong><br />\n<br />\nScale a floating-point matrix.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> whose <em>Column Type</em> is a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>Matrix</em> must be the same as <em>Result Type</em>. Each component in each column in <em>Matrix</em> is multiplied by <em>Scalar</em>.<br />\n<br />\n<em>Scalar</em> must have the same type as the <em>Component Type</em> in <em>Result Type</em>.",
    "DescriptionPlain": "OpMatrixTimesScalar\n\nScale a floating-point matrix.\n\n Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. \n\n The type of Matrix must be the same as Result Type. Each component in each column in Matrix is multiplied by Scalar.\n\nScalar must have the same type as the Component Type in Result Type.",
    "Category": "Arithmetic",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 143,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Matrix",
        "Type": "ID"
      },
      {
        "Name": "Scalar",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpVectorTimesMatrix",
    "Description": "<a id=\"OpVectorTimesMatrix\"></a><strong>OpVectorTimesMatrix</strong><br />\n<br />\nLinear-algebraic <em>Vector X Matrix</em>.<br />\n<br />\n <em>Result Type</em> must be a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Vector</em> must be a vector with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of components must equal the number of components in each column in <em>Matrix</em>.<br />\n<br />\n<em>Matrix</em> must be a matrix with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of columns must equal the number of components in <em>Result Type</em>.",
    "DescriptionPlain": "OpVectorTimesMatrix\n\nLinear-algebraic Vector X Matrix.\n\n Result Type must be a vector of floating-point type. \n\nVector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of components in each column in Matrix.\n\nMatrix must be a matrix with the same Component Type as the Component Type in Result Type. Its number of columns must equal the number of components in Result Type.",
    "Category": "Arithmetic",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 144,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector",
        "Type": "ID"
      },
      {
        "Name": "Matrix",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpMatrixTimesVector",
    "Description": "<a id=\"OpMatrixTimesVector\"></a><strong>OpMatrixTimesVector</strong><br />\n<br />\nLinear-algebraic <em>Vector X Matrix</em>.<br />\n<br />\n <em>Result Type</em> must be a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Matrix</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> whose <em>Column Type</em> is <em>Result Type</em>.<br />\n<br />\n<em>Vector</em> must be a vector with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of components must equal the number of columns in <em>Matrix</em>.",
    "DescriptionPlain": "OpMatrixTimesVector\n\nLinear-algebraic Vector X Matrix.\n\n Result Type must be a vector of floating-point type. \n\nMatrix must be an OpTypeMatrix whose Column Type is Result Type.\n\nVector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Matrix.",
    "Category": "Arithmetic",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 145,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Matrix",
        "Type": "ID"
      },
      {
        "Name": "Vector",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpMatrixTimesMatrix",
    "Description": "<a id=\"OpMatrixTimesMatrix\"></a><strong>OpMatrixTimesMatrix</strong><br />\n<br />\nLinear-algebraic multiply of <em>LeftMatrix</em> X <em>RightMatrix</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> whose <em>Column Type</em> is a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>LeftMatrix</em> must be a matrix whose <em>Column Type</em> is the same as the <em>Column Type</em> in <em>Result Type</em>.<br />\n<br />\n<em>RightMatrix</em> must be a matrix with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of columns must equal the number of columns in <em>Result Type</em>. Its columns must have the same number of components as the number of columns in <em>LeftMatrix</em>.",
    "DescriptionPlain": "OpMatrixTimesMatrix\n\nLinear-algebraic multiply of LeftMatrix X RightMatrix.\n\n Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. \n\nLeftMatrix must be a matrix whose Column Type is the same as the Column Type in Result Type.\n\nRightMatrix must be a matrix with the same Component Type as the Component Type in Result Type. Its number of columns must equal the number of columns in Result Type. Its columns must have the same number of components as the number of columns in LeftMatrix.",
    "Category": "Arithmetic",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 146,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "LeftMatrix",
        "Type": "ID"
      },
      {
        "Name": "RightMatrix",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpOuterProduct",
    "Description": "<a id=\"OpOuterProduct\"></a><strong>OpOuterProduct</strong><br />\n<br />\nLinear-algebraic outer product of <em>Vector 1</em> and <em>Vector 2</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> whose <em>Column Type</em> is a vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Vector 1</em> must have the same type as the <em>Column Type</em> in <em>Result Type</em>.<br />\n<br />\n<em>Vector 2</em> must be a vector with the same <em>Component Type</em> as the <em>Component Type</em> in <em>Result Type</em>. Its number of components must equal the number of columns in <em>Result Type</em>.",
    "DescriptionPlain": "OpOuterProduct\n\nLinear-algebraic outer product of Vector 1 and Vector 2.\n\n Result Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type. \n\nVector 1 must have the same type as the Column Type in Result Type.\n\nVector 2 must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Result Type.",
    "Category": "Arithmetic",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 147,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector1",
        "Type": "ID"
      },
      {
        "Name": "Vector2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpDot",
    "Description": "<a id=\"OpDot\"></a><strong>OpDot</strong><br />\n<br />\nDot product of <em>Vector 1</em> and <em>Vector 2</em>.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Floating\"><em>floating-point type</em></a> scalar. <br />\n<br />\n<em>Vector 1</em> and <em>Vector 2</em> must have the same type, and their component type must be <em>Result Type</em>.",
    "DescriptionPlain": "OpDot\n\nDot product of Vector 1 and Vector 2.\n\n Result Type must be a floating-point type scalar. \n\nVector 1 and Vector 2 must have the same type, and their component type must be Result Type.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 148,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector1",
        "Type": "ID"
      },
      {
        "Name": "Vector2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIAddCarry",
    "Description": "<a id=\"OpIAddCarry\"></a><strong>OpIAddCarry</strong><br />\n<br />\nResult is the unsigned integer addition of <em>Operand 1</em> and <em>Operand 2</em>, including its carry.<br />\n<br />\n<em>Result Type</em> must be from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Operand 1</em> and <em>Operand 2</em> must have the same type as the members of <em>Result Type</em>. These are consumed as unsigned integers.<br />\n<br />\n Results are computed per component. <br />\n<br />\nMember 0 of the result gets the low-order bits (full component width) of the addition.<br />\n<br />\nMember 1 of the result gets the high-order (carry) bit of the result of the addition. That is, it gets the value 1 if the addition overflowed the component width, and 0 otherwise.",
    "DescriptionPlain": "OpIAddCarry\n\nResult is the unsigned integer addition of Operand 1 and Operand 2, including its carry.\n\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\n\n Results are computed per component. \n\nMember 0 of the result gets the low-order bits (full component width) of the addition.\n\nMember 1 of the result gets the high-order (carry) bit of the result of the addition. That is, it gets the value 1 if the addition overflowed the component width, and 0 otherwise.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 149,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpISubBorrow",
    "Description": "<a id=\"OpISubBorrow\"></a><strong>OpISubBorrow</strong><br />\n<br />\nResult is the unsigned integer subtraction of <em>Operand 2</em> from <em>Operand 1</em>, and what it needed to borrow.<br />\n<br />\n<em>Result Type</em> must be from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Operand 1</em> and <em>Operand 2</em> must have the same type as the members of <em>Result Type</em>. These are consumed as unsigned integers.<br />\n<br />\n Results are computed per component. <br />\n<br />\nMember 0 of the result gets the low-order bits (full component width) of the subtraction. That is, if <em>Operand 1</em> is larger than <em>Operand 2</em>, member 0 gets the full value of the subtraction;  if <em>Operand 2</em> is larger than <em>Operand 1</em>, member 0 gets <em>2<sup>w</sup></em> + <em>Operand 1</em> - <em>Operand 2</em>, where <em>w</em> is the component width.<br />\n<br />\nMember 1 of the result gets 0 if <em>Operand 1</em> &ge; <em>Operand 2</em>, and gets 1 otherwise.",
    "DescriptionPlain": "OpISubBorrow\n\nResult is the unsigned integer subtraction of Operand 2 from Operand 1, and what it needed to borrow.\n\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\n\n Results are computed per component. \n\nMember 0 of the result gets the low-order bits (full component width) of the subtraction. That is, if Operand 1 is larger than Operand 2, member 0 gets the full value of the subtraction;  if Operand 2 is larger than Operand 1, member 0 gets 2w + Operand 1 - Operand 2, where w is the component width.\n\nMember 1 of the result gets 0 if Operand 1 &ge; Operand 2, and gets 1 otherwise.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 150,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpUMulExtended",
    "Description": "<a id=\"OpUMulExtended\"></a><strong>OpUMulExtended</strong><br />\n<br />\nResult is the full value of the unsigned integer multiplication of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n<em>Result Type</em> must be from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>, whose <em>Signedness</em> operand is 0. <br />\n<br />\n<em>Operand 1</em> and <em>Operand 2</em> must have the same type as the members of <em>Result Type</em>. These are consumed as unsigned integers.<br />\n<br />\n Results are computed per component. <br />\n<br />\nMember 0 of the result gets the low-order bits of the multiplication.<br />\n<br />\nMember 1 of the result gets the high-order bits of the multiplication.",
    "DescriptionPlain": "OpUMulExtended\n\nResult is the full value of the unsigned integer multiplication of Operand 1 and Operand 2.\n\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0. \n\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\n\n Results are computed per component. \n\nMember 0 of the result gets the low-order bits of the multiplication.\n\nMember 1 of the result gets the high-order bits of the multiplication.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 151,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSMulExtended",
    "Description": "<a id=\"OpSMulExtended\"></a><strong>OpSMulExtended</strong><br />\n<br />\nResult is the full value of the signed integer multiplication of <em>Operand 1</em> and <em>Operand 2</em>.<br />\n<br />\n<em>Result Type</em> must be from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Operand 1</em> and <em>Operand 2</em> must have the same type as the members of <em>Result Type</em>. These are consumed as signed integers.<br />\n<br />\n Results are computed per component. <br />\n<br />\nMember 0 of the result gets the low-order bits of the multiplication.<br />\n<br />\nMember 1 of the result gets the high-order bits of the multiplication.",
    "DescriptionPlain": "OpSMulExtended\n\nResult is the full value of the signed integer multiplication of Operand 1 and Operand 2.\n\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type. \n\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as signed integers.\n\n Results are computed per component. \n\nMember 0 of the result gets the low-order bits of the multiplication.\n\nMember 1 of the result gets the high-order bits of the multiplication.",
    "Category": "Arithmetic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 152,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpShiftRightLogical",
    "Description": "<a id=\"OpShiftRightLogical\"></a><strong>OpShiftRightLogical</strong><br />\n<br />\nShift the bits in <em>Base</em> right by the number of bits specified in <em>Shift</em>.  The most-significant bits will be zero filled. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of each <em>Base</em> and <em>Shift</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <em>Base</em> and <em>Shift</em> must have the same number of components.  The number of components and bit width of the type of <em>Base</em> must be the same as in <em>Result Type</em>. <br />\n<br />\n<em>Shift</em> is consumed as an unsigned integer. The result is undefined if <em>Shift</em> is greater than the bit width of the components of <em>Base</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpShiftRightLogical\n\nShift the bits in Base right by the number of bits specified in Shift.  The most-significant bits will be zero filled. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. \n\nShift is consumed as an unsigned integer. The result is undefined if Shift is greater than the bit width of the components of Base.\n\n Results are computed per component.",
    "Category": "Bit",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 194,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Shift",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpShiftRightArithmetic",
    "Description": "<a id=\"OpShiftRightArithmetic\"></a><strong>OpShiftRightArithmetic</strong><br />\n<br />\nShift the bits in <em>Base</em> right by the number of bits specified in <em>Shift</em>. The most-significant bits will be filled with the sign bit from <em>Base</em>. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of each <em>Base</em> and <em>Shift</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <em>Base</em> and <em>Shift</em> must have the same number of components.  The number of components and bit width of the type of <em>Base</em> must be the same as in <em>Result Type</em>. <br />\n<br />\n<em>Shift</em> is treated as unsigned.  The result is undefined if <em>Shift</em> is greater than the bit width of the components of <em>Base</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpShiftRightArithmetic\n\nShift the bits in Base right by the number of bits specified in Shift. The most-significant bits will be filled with the sign bit from Base. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. \n\nShift is treated as unsigned.  The result is undefined if Shift is greater than the bit width of the components of Base. \n\n Results are computed per component.",
    "Category": "Bit",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 195,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Shift",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpShiftLeftLogical",
    "Description": "<a id=\"OpShiftLeftLogical\"></a><strong>OpShiftLeftLogical</strong><br />\n<br />\nShift the bits in <em>Base</em> left by the number of bits specified in <em>Shift</em>. The least-significant bits will be zero filled. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of each <em>Base</em> and <em>Shift</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <em>Base</em> and <em>Shift</em> must have the same number of components.  The number of components and bit width of the type of <em>Base</em> must be the same as in <em>Result Type</em>. <br />\n<br />\n<em>Shift</em> is treated as unsigned.  The result is undefined if <em>Shift</em> is greater than the bit width of the components of <em>Base</em>. <br />\n<br />\nThe number of components and bit width of <em>Result Type</em> must match those <em>Base</em> type. All types must be integer types.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpShiftLeftLogical\n\nShift the bits in Base left by the number of bits specified in Shift. The least-significant bits will be zero filled. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type. \n\nShift is treated as unsigned.  The result is undefined if Shift is greater than the bit width of the components of Base. \n\nThe number of components and bit width of Result Type must match those Base type. All types must be integer types.\n\n Results are computed per component.",
    "Category": "Bit",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 196,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Shift",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBitwiseOr",
    "Description": "<a id=\"OpBitwiseOr\"></a><strong>OpBitwiseOr</strong><br />\n<br />\nResult is 1 if either <em>Operand 1</em> or <em>Operand 2</em> is 1. Result is 0 if both <em>Operand 1</em> and <em>Operand 2</em> are 0.<br />\n<br />\n Results are computed per component, and within each component, per bit. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>.",
    "DescriptionPlain": "OpBitwiseOr\n\nResult is 1 if either Operand 1 or Operand 2 is 1. Result is 0 if both Operand 1 and Operand 2 are 0.\n\n Results are computed per component, and within each component, per bit. \n\n Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
    "Category": "Bit",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 197,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBitwiseXor",
    "Description": "<a id=\"OpBitwiseXor\"></a><strong>OpBitwiseXor</strong><br />\n<br />\nResult is 1 if exactly one of <em>Operand 1</em> or <em>Operand 2</em> is 1. Result is 0 if <em>Operand 1</em> and <em>Operand 2</em> have the same value.<br />\n<br />\n Results are computed per component, and within each component, per bit. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>.",
    "DescriptionPlain": "OpBitwiseXor\n\nResult is 1 if exactly one of Operand 1 or Operand 2 is 1. Result is 0 if Operand 1 and Operand 2 have the same value.\n\n Results are computed per component, and within each component, per bit. \n\n Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
    "Category": "Bit",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 198,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBitwiseAnd",
    "Description": "<a id=\"OpBitwiseAnd\"></a><strong>OpBitwiseAnd</strong><br />\n<br />\nResult is 1 if both <em>Operand 1</em> and <em>Operand 2</em> are 1. Result is 0 if either <em>Operand 1</em> or <em>Operand 2</em> are 0.<br />\n<br />\n Results are computed per component, and within each component, per bit. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same number of components as <em>Result Type</em>. They must have the same component width as <em>Result Type</em>.",
    "DescriptionPlain": "OpBitwiseAnd\n\nResult is 1 if both Operand 1 and Operand 2 are 1. Result is 0 if either Operand 1 or Operand 2 are 0.\n\n Results are computed per component, and within each component, per bit. \n\n Result Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
    "Category": "Bit",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 199,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpNot",
    "Description": "<a id=\"OpNot\"></a><strong>OpNot</strong><br />\n<br />\nComplement the bits of <em>Operand</em>.<br />\n<br />\n Results are computed per component, and within each component, per bit. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n <em>Operand&#8217;s</em> type  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.  The component width must equal the component width in <em>Result Type</em>.",
    "DescriptionPlain": "OpNot\n\nComplement the bits of Operand.\n\n Results are computed per component, and within each component, per bit. \n\n Result Type must be a scalar or vector of integer type. \n\n Operand&#8217;s type  must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must equal the component width in Result Type.",
    "Category": "Bit",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 200,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBitFieldInsert",
    "Description": "<a id=\"OpBitFieldInsert\"></a><strong>OpBitFieldInsert</strong><br />\n<br />\nMake a copy of an object, with a modified bit field that comes from another object.<br />\n<br />\n Results are computed per component. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Base</em> and <em>Insert</em> must be the same as <em>Result Type</em>. <br />\n<br />\nAny result bits numbered outside [<em>Offset</em>, <em>Offset</em> + <em>Count</em> -  1] (<a href=\"#Inclusive\">inclusive</a>) will come from the corresponding bits in <em>Base</em>.<br />\n<br />\nAny result bits numbered in [<em>Offset</em>, <em>Offset</em> + <em>Count</em> -  1] come, in order, from the bits numbered [0, <em>Count</em> - 1] of <em>Insert</em>.<br />\n<br />\n<em>Count</em>  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <em>Count</em> is the number of bits taken from <em>Insert</em>. It will be consumed as an unsigned value. <em>Count</em> can be 0, in which case the result will be <em>Base</em>.<br />\n<br />\n<em>Offset</em>  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <em>Offset</em> is the lowest-order bit of the bit field.  It will be consumed as an unsigned value.<br />\n<br />\nThe resulting value is undefined if <em>Count</em> or <em>Offset</em> or their sum is greater than the number of bits in the result.",
    "DescriptionPlain": "OpBitFieldInsert\n\nMake a copy of an object, with a modified bit field that comes from another object.\n\n Results are computed per component. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of Base and Insert must be the same as Result Type. \n\nAny result bits numbered outside [Offset, Offset + Count -  1] (inclusive) will come from the corresponding bits in Base.\n\nAny result bits numbered in [Offset, Offset + Count -  1] come, in order, from the bits numbered [0, Count - 1] of Insert.\n\nCount  must be an integer type scalar. Count is the number of bits taken from Insert. It will be consumed as an unsigned value. Count can be 0, in which case the result will be Base.\n\nOffset  must be an integer type scalar. Offset is the lowest-order bit of the bit field.  It will be consumed as an unsigned value.\n\nThe resulting value is undefined if Count or Offset or their sum is greater than the number of bits in the result.",
    "Category": "Bit",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 201,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Insert",
        "Type": "ID"
      },
      {
        "Name": "Offset",
        "Type": "ID"
      },
      {
        "Name": "Count",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBitFieldSExtract",
    "Description": "<a id=\"OpBitFieldSExtract\"></a><strong>OpBitFieldSExtract</strong><br />\n<br />\nExtract a bit field from an object, with sign extension.<br />\n<br />\n Results are computed per component. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Base</em> must be the same as <em>Result Type</em>. <br />\n<br />\nIf <em>Count</em> is greater than 0: The bits of <em>Base</em> numbered in [<em>Offset</em>, <em>Offset</em> + <em>Count</em> -  1] (<a href=\"#Inclusive\">inclusive</a>) become the bits numbered [0, <em>Count</em> - 1] of the result. The remaining bits of the result will all be the same as bit <em>Offset + Count -  1</em> of <em>Base</em>.<br />\n<br />\n<em>Count</em>  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <em>Count</em> is the number of bits extracted from <em>Base</em>. It will be consumed as an unsigned value. <em>Count</em> can be 0, in which case the result will be 0.<br />\n<br />\n<em>Offset</em>  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <em>Offset</em> is the lowest-order bit of the bit field to extract from <em>Base</em>.  It will be consumed as an unsigned value.<br />\n<br />\nThe resulting value is undefined if <em>Count</em> or <em>Offset</em> or their sum is greater than the number of bits in the result.",
    "DescriptionPlain": "OpBitFieldSExtract\n\nExtract a bit field from an object, with sign extension.\n\n Results are computed per component. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of Base must be the same as Result Type. \n\nIf Count is greater than 0: The bits of Base numbered in [Offset, Offset + Count -  1] (inclusive) become the bits numbered [0, Count - 1] of the result. The remaining bits of the result will all be the same as bit Offset + Count -  1 of Base.\n\nCount  must be an integer type scalar. Count is the number of bits extracted from Base. It will be consumed as an unsigned value. Count can be 0, in which case the result will be 0.\n\nOffset  must be an integer type scalar. Offset is the lowest-order bit of the bit field to extract from Base.  It will be consumed as an unsigned value.\n\nThe resulting value is undefined if Count or Offset or their sum is greater than the number of bits in the result.",
    "Category": "Bit",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 202,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Offset",
        "Type": "ID"
      },
      {
        "Name": "Count",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBitFieldUExtract",
    "Description": "<a id=\"OpBitFieldUExtract\"></a><strong>OpBitFieldUExtract</strong><br />\n<br />\nExtract a bit field from an object, without sign extension.<br />\n<br />\nThe semantics are the same as with <a href=\"#OpBitFieldSExtract\"><strong>OpBitFieldSExtract</strong></a> with the exception that there is no sign extension. The remaining bits of the result will all be 0.",
    "DescriptionPlain": "OpBitFieldUExtract\n\nExtract a bit field from an object, without sign extension.\n\nThe semantics are the same as with OpBitFieldSExtract with the exception that there is no sign extension. The remaining bits of the result will all be 0.",
    "Category": "Bit",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 203,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      },
      {
        "Name": "Offset",
        "Type": "ID"
      },
      {
        "Name": "Count",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBitReverse",
    "Description": "<a id=\"OpBitReverse\"></a><strong>OpBitReverse</strong><br />\n<br />\nReverse the bits in an object.<br />\n<br />\n Results are computed per component. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n The type of <em>Base</em> must be the same as <em>Result Type</em>. <br />\n<br />\nThe bit-number <em>n</em> of the result will be taken from bit-number <em>Width - 1 - n</em> of <em>Base</em>, where <em>Width</em> is the <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> operand of the <em>Result Type</em>.",
    "DescriptionPlain": "OpBitReverse\n\nReverse the bits in an object.\n\n Results are computed per component. \n\n Result Type must be a scalar or vector of integer type. \n\n The type of Base must be the same as Result Type. \n\nThe bit-number n of the result will be taken from bit-number Width - 1 - n of Base, where Width is the OpTypeInt operand of the Result Type.",
    "Category": "Bit",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 204,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBitCount",
    "Description": "<a id=\"OpBitCount\"></a><strong>OpBitCount</strong><br />\n<br />\nCount the number of set bits in an object.<br />\n<br />\n Results are computed per component. <br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  The components must be wide enough to hold the unsigned <em>Width</em> of <em>Base</em> as an unsigned value. That is, no sign bit is needed or counted when checking for a wide enough result width.<br />\n<br />\n<em>Base</em> must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\nThe result is the unsigned value that is the number of bits in <em>Base</em> that are 1.",
    "DescriptionPlain": "OpBitCount\n\nCount the number of set bits in an object.\n\n Results are computed per component. \n\n Result Type must be a scalar or vector of integer type.  The components must be wide enough to hold the unsigned Width of Base as an unsigned value. That is, no sign bit is needed or counted when checking for a wide enough result width.\n\nBase must be a scalar or vector of integer type.  It must have the same number of components as Result Type.\n\nThe result is the unsigned value that is the number of bits in Base that are 1.",
    "Category": "Bit",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 205,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Base",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAny",
    "Description": "<a id=\"OpAny\"></a><strong>OpAny</strong><br />\n<br />\nResult is <strong>true</strong> if any component of <em>Vector</em> is <strong>true</strong>, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar. <br />\n<br />\n<em>Vector</em> must be a vector of <a href=\"#Boolean\"><em>Boolean type</em></a>.",
    "DescriptionPlain": "OpAny\n\nResult is true if any component of Vector is true, otherwise result is false.\n\n Result Type must be a Boolean type scalar. \n\nVector must be a vector of Boolean type.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 154,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAll",
    "Description": "<a id=\"OpAll\"></a><strong>OpAll</strong><br />\n<br />\nResult is <strong>true</strong> if all components of <em>Vector</em> are <strong>true</strong>, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar. <br />\n<br />\n<em>Vector</em> must be a vector of <a href=\"#Boolean\"><em>Boolean type</em></a>.",
    "DescriptionPlain": "OpAll\n\nResult is true if all components of Vector are true, otherwise result is false.\n\n Result Type must be a Boolean type scalar. \n\nVector must be a vector of Boolean type.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 155,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Vector",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIsNan",
    "Description": "<a id=\"OpIsNan\"></a><strong>OpIsNan</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE NaN, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpIsNan\n\nResult is true if x is an IEEE NaN, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 156,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIsInf",
    "Description": "<a id=\"OpIsInf\"></a><strong>OpIsInf</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE Inf, otherwise result is <strong>false</strong><br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpIsInf\n\nResult is true if x is an IEEE Inf, otherwise result is false\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 157,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIsFinite",
    "Description": "<a id=\"OpIsFinite\"></a><strong>OpIsFinite</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE finite number, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpIsFinite\n\nResult is true if x is an IEEE finite number, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 158,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIsNormal",
    "Description": "<a id=\"OpIsNormal\"></a><strong>OpIsNormal</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE normal number, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpIsNormal\n\nResult is true if x is an IEEE normal number, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 159,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSignBitSet",
    "Description": "<a id=\"OpSignBitSet\"></a><strong>OpSignBitSet</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> has its sign bit set, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSignBitSet\n\nResult is true if x has its sign bit set, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 160,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpLessOrGreater",
    "Description": "<a id=\"OpLessOrGreater\"></a><strong>OpLessOrGreater</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> &lt; <em>y</em> or <em>x</em> &gt; <em>y</em>, where IEEE comparisons are used, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n<em>y</em> must have the same type as <em>x</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpLessOrGreater\n\nResult is true if x &lt; y or x &gt; y, where IEEE comparisons are used, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\ny must have the same type as x.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 161,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "X",
        "Type": "ID"
      },
      {
        "Name": "Y",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpOrdered",
    "Description": "<a id=\"OpOrdered\"></a><strong>OpOrdered</strong><br />\n<br />\nResult is <strong>true</strong> if both <em>x</em> == <em>x</em> and <em>y</em> == <em>y</em> are <strong>true</strong>, where IEEE comparison is used, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n<em>y</em> must have the same type as <em>x</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpOrdered\n\nResult is true if both x == x and y == y are true, where IEEE comparison is used, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\ny must have the same type as x.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 162,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "X",
        "Type": "ID"
      },
      {
        "Name": "Y",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpUnordered",
    "Description": "<a id=\"OpUnordered\"></a><strong>OpUnordered</strong><br />\n<br />\nResult is <strong>true</strong> if either <em>x</em> or <em>y</em> is an IEEE NaN, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n<em>x</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n<em>y</em> must have the same type as <em>x</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpUnordered\n\nResult is true if either x or y is an IEEE NaN, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type. \n\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\n\ny must have the same type as x.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 163,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "X",
        "Type": "ID"
      },
      {
        "Name": "Y",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpLogicalEqual",
    "Description": "<a id=\"OpLogicalEqual\"></a><strong>OpLogicalEqual</strong><br />\n<br />\nResult is <strong>true</strong> if <em>Operand 1</em> and <em>Operand 2</em> have the same value. Result is <strong>false</strong> if <em>Operand 1</em> and <em>Operand 2</em> have different values.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> must be the same as <em>Result Type</em>. <br />\n<br />\n The type of <em>Operand 2</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpLogicalEqual\n\nResult is true if Operand 1 and Operand 2 have the same value. Result is false if Operand 1 and Operand 2 have different values.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 must be the same as Result Type. \n\n The type of Operand 2 must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 164,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpLogicalNotEqual",
    "Description": "<a id=\"OpLogicalNotEqual\"></a><strong>OpLogicalNotEqual</strong><br />\n<br />\nResult is <strong>true</strong> if <em>Operand 1</em> and <em>Operand 2</em> have different values. Result is <strong>false</strong> if <em>Operand 1</em> and <em>Operand 2</em> have the same value.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> must be the same as <em>Result Type</em>. <br />\n<br />\n The type of <em>Operand 2</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpLogicalNotEqual\n\nResult is true if Operand 1 and Operand 2 have different values. Result is false if Operand 1 and Operand 2 have the same value.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 must be the same as Result Type. \n\n The type of Operand 2 must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 165,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpLogicalOr",
    "Description": "<a id=\"OpLogicalOr\"></a><strong>OpLogicalOr</strong><br />\n<br />\nResult is <strong>true</strong> if either <em>Operand 1</em> or <em>Operand 2</em> is <strong>true</strong>. Result is <strong>false</strong> if both <em>Operand 1</em> and <em>Operand 2</em> are <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> must be the same as <em>Result Type</em>. <br />\n<br />\n The type of <em>Operand 2</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpLogicalOr\n\nResult is true if either Operand 1 or Operand 2 is true. Result is false if both Operand 1 and Operand 2 are false.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 must be the same as Result Type. \n\n The type of Operand 2 must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 166,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpLogicalAnd",
    "Description": "<a id=\"OpLogicalAnd\"></a><strong>OpLogicalAnd</strong><br />\n<br />\nResult is <strong>true</strong> if both <em>Operand 1</em> and <em>Operand 2</em> are <strong>true</strong>. Result is <strong>false</strong> if either <em>Operand 1</em> or <em>Operand 2</em> are <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> must be the same as <em>Result Type</em>. <br />\n<br />\n The type of <em>Operand 2</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpLogicalAnd\n\nResult is true if both Operand 1 and Operand 2 are true. Result is false if either Operand 1 or Operand 2 are false.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 must be the same as Result Type. \n\n The type of Operand 2 must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 167,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpLogicalNot",
    "Description": "<a id=\"OpLogicalNot\"></a><strong>OpLogicalNot</strong><br />\n<br />\nResult is <strong>true</strong> if <em>Operand</em> is <strong>false</strong>.  Result is <strong>false</strong> if <em>Operand</em> is <strong>true</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand</em> must be the same as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpLogicalNot\n\nResult is true if Operand is false.  Result is false if Operand is true.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand must be the same as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 168,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSelect",
    "Description": "<a id=\"OpSelect\"></a><strong>OpSelect</strong><br />\n<br />\nSelect between two objects.<br />\n<br />\n<em>Result Type</em> must be a scalar or vector.<br />\n<br />\n The type of <em>Object 1</em> must be the same as <em>Result Type</em>. <em>Object 1</em> is selected as the result if <em>Condition</em> is <strong>true</strong>.<br />\n<br />\n The type of <em>Object 2</em> must be the same as <em>Result Type</em>. <em>Object 2</em> is selected as the result if <em>Condition</em> is <strong>false</strong>.<br />\n<br />\n<em>Condition</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>.  It must have the same number of components as <em>Result Type</em>.<br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSelect\n\nSelect between two objects.\n\nResult Type must be a scalar or vector.\n\n The type of Object 1 must be the same as Result Type. Object 1 is selected as the result if Condition is true.\n\n The type of Object 2 must be the same as Result Type. Object 2 is selected as the result if Condition is false.\n\nCondition must be a scalar or vector of Boolean type.  It must have the same number of components as Result Type.\n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 169,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Condition",
        "Type": "ID"
      },
      {
        "Name": "Object1",
        "Type": "ID"
      },
      {
        "Name": "Object2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIEqual",
    "Description": "<a id=\"OpIEqual\"></a><strong>OpIEqual</strong><br />\n<br />\nInteger comparison for equality.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpIEqual\n\nInteger comparison for equality.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 170,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpINotEqual",
    "Description": "<a id=\"OpINotEqual\"></a><strong>OpINotEqual</strong><br />\n<br />\nInteger comparison for inequality.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpINotEqual\n\nInteger comparison for inequality.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 171,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpUGreaterThan",
    "Description": "<a id=\"OpUGreaterThan\"></a><strong>OpUGreaterThan</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpUGreaterThan\n\nUnsigned-integer comparison if Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 172,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSGreaterThan",
    "Description": "<a id=\"OpSGreaterThan\"></a><strong>OpSGreaterThan</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSGreaterThan\n\nSigned-integer comparison if Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 173,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpUGreaterThanEqual",
    "Description": "<a id=\"OpUGreaterThanEqual\"></a><strong>OpUGreaterThanEqual</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpUGreaterThanEqual\n\nUnsigned-integer comparison if Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 174,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSGreaterThanEqual",
    "Description": "<a id=\"OpSGreaterThanEqual\"></a><strong>OpSGreaterThanEqual</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSGreaterThanEqual\n\nSigned-integer comparison if Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 175,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpULessThan",
    "Description": "<a id=\"OpULessThan\"></a><strong>OpULessThan</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpULessThan\n\nUnsigned-integer comparison if Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 176,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSLessThan",
    "Description": "<a id=\"OpSLessThan\"></a><strong>OpSLessThan</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSLessThan\n\nSigned-integer comparison if Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 177,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpULessThanEqual",
    "Description": "<a id=\"OpULessThanEqual\"></a><strong>OpULessThanEqual</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpULessThanEqual\n\nUnsigned-integer comparison if Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 178,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSLessThanEqual",
    "Description": "<a id=\"OpSLessThanEqual\"></a><strong>OpSLessThanEqual</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Integer\"><em>integer type</em></a>.  They must have the same component width, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpSLessThanEqual\n\nSigned-integer comparison if Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 179,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFOrdEqual",
    "Description": "<a id=\"OpFOrdEqual\"></a><strong>OpFOrdEqual</strong><br />\n<br />\nFloating-point comparison for being ordered and equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFOrdEqual\n\nFloating-point comparison for being ordered and equal.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 180,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFUnordEqual",
    "Description": "<a id=\"OpFUnordEqual\"></a><strong>OpFUnordEqual</strong><br />\n<br />\nFloating-point comparison for being unordered or equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFUnordEqual\n\nFloating-point comparison for being unordered or equal.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 181,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFOrdNotEqual",
    "Description": "<a id=\"OpFOrdNotEqual\"></a><strong>OpFOrdNotEqual</strong><br />\n<br />\nFloating-point comparison for being ordered and not equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFOrdNotEqual\n\nFloating-point comparison for being ordered and not equal.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 182,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFUnordNotEqual",
    "Description": "<a id=\"OpFUnordNotEqual\"></a><strong>OpFUnordNotEqual</strong><br />\n<br />\nFloating-point comparison for being unordered or not equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFUnordNotEqual\n\nFloating-point comparison for being unordered or not equal.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 183,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFOrdLessThan",
    "Description": "<a id=\"OpFOrdLessThan\"></a><strong>OpFOrdLessThan</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFOrdLessThan\n\nFloating-point comparison if operands are ordered and Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 184,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFUnordLessThan",
    "Description": "<a id=\"OpFUnordLessThan\"></a><strong>OpFUnordLessThan</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFUnordLessThan\n\nFloating-point comparison if operands are unordered or Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 185,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFOrdGreaterThan",
    "Description": "<a id=\"OpFOrdGreaterThan\"></a><strong>OpFOrdGreaterThan</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFOrdGreaterThan\n\nFloating-point comparison if operands are ordered and Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 186,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFUnordGreaterThan",
    "Description": "<a id=\"OpFUnordGreaterThan\"></a><strong>OpFUnordGreaterThan</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFUnordGreaterThan\n\nFloating-point comparison if operands are unordered or Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 187,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFOrdLessThanEqual",
    "Description": "<a id=\"OpFOrdLessThanEqual\"></a><strong>OpFOrdLessThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFOrdLessThanEqual\n\nFloating-point comparison if operands are ordered and Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 188,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFUnordLessThanEqual",
    "Description": "<a id=\"OpFUnordLessThanEqual\"></a><strong>OpFUnordLessThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFUnordLessThanEqual\n\nFloating-point comparison if operands are unordered or Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 189,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFOrdGreaterThanEqual",
    "Description": "<a id=\"OpFOrdGreaterThanEqual\"></a><strong>OpFOrdGreaterThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFOrdGreaterThanEqual\n\nFloating-point comparison if operands are ordered and Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 190,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFUnordGreaterThanEqual",
    "Description": "<a id=\"OpFUnordGreaterThanEqual\"></a><strong>OpFUnordGreaterThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>. <br />\n<br />\n The type of <em>Operand 1</em> and <em>Operand 2</em>  must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>.  They must have the same type, and they must have the same number of components as <em>Result Type</em>. <br />\n<br />\n Results are computed per component.",
    "DescriptionPlain": "OpFUnordGreaterThanEqual\n\nFloating-point comparison if operands are unordered or Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type. \n\n The type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type. \n\n Results are computed per component.",
    "Category": "RelationalAndLogical",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 191,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Operand1",
        "Type": "ID"
      },
      {
        "Name": "Operand2",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpDPdx",
    "Description": "<a id=\"OpDPdx\"></a><strong>OpDPdx</strong><br />\n<br />\nSame result as either <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a> or <a href=\"#OpDPdxCoarse\"><strong>OpDPdxCoarse</strong></a> on <em>P</em>. Selection of which one is based on external factors.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpDPdx\n\nSame result as either OpDPdxFine or OpDPdxCoarse on P. Selection of which one is based on external factors.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 207,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpDPdy",
    "Description": "<a id=\"OpDPdy\"></a><strong>OpDPdy</strong><br />\n<br />\nSame result as either <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a> or <a href=\"#OpDPdyCoarse\"><strong>OpDPdyCoarse</strong></a> on <em>P</em>. Selection of which one is based on external factors.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpDPdy\n\nSame result as either OpDPdyFine or OpDPdyCoarse on P. Selection of which one is based on external factors.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 208,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFwidth",
    "Description": "<a id=\"OpFwidth\"></a><strong>OpFwidth</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdx\"><strong>OpDPdx</strong></a> and <a href=\"#OpDPdy\"><strong>OpDPdy</strong></a> on <em>P</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpFwidth\n\nResult is the same as computing the sum of the absolute values of OpDPdx and OpDPdy on P.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 209,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpDPdxFine",
    "Description": "<a id=\"OpDPdxFine\"></a><strong>OpDPdxFine</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>x</em> coordinate.Will use local differencing based on the value of <em>P</em> for the current fragment and its immediate neighbor(s).<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpDPdxFine\n\nResult is the partial derivative of P with respect to the window x coordinate.Will use local differencing based on the value of P for the current fragment and its immediate neighbor(s).\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 210,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpDPdyFine",
    "Description": "<a id=\"OpDPdyFine\"></a><strong>OpDPdyFine</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>y</em> coordinate.Will use local differencing based on the value of <em>P</em> for the current fragment and its immediate neighbor(s).<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpDPdyFine\n\nResult is the partial derivative of P with respect to the window y coordinate.Will use local differencing based on the value of P for the current fragment and its immediate neighbor(s).\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 211,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFwidthFine",
    "Description": "<a id=\"OpFwidthFine\"></a><strong>OpFwidthFine</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a> and <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a> on <em>P</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpFwidthFine\n\nResult is the same as computing the sum of the absolute values of OpDPdxFine and OpDPdyFine on P.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 212,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpDPdxCoarse",
    "Description": "<a id=\"OpDPdxCoarse\"></a><strong>OpDPdxCoarse</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>x</em> coordinate. Will use local differencing based on the value of <em>P</em> for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of <em>P</em> for the current fragment. That is, over a given area, the implementation can compute <em>x</em> derivatives in fewer unique locations than would be allowed for <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpDPdxCoarse\n\nResult is the partial derivative of P with respect to the window x coordinate. Will use local differencing based on the value of P for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of P for the current fragment. That is, over a given area, the implementation can compute x derivatives in fewer unique locations than would be allowed for OpDPdxFine.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 213,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpDPdyCoarse",
    "Description": "<a id=\"OpDPdyCoarse\"></a><strong>OpDPdyCoarse</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>y</em> coordinate. Will use local differencing based on the value of <em>P</em> for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of <em>P</em> for the current fragment. That is, over a given area, the implementation can compute <em>y</em> derivatives in fewer unique locations than would be allowed for <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpDPdyCoarse\n\nResult is the partial derivative of P with respect to the window y coordinate. Will use local differencing based on the value of P for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of P for the current fragment. That is, over a given area, the implementation can compute y derivatives in fewer unique locations than would be allowed for OpDPdyFine.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 214,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpFwidthCoarse",
    "Description": "<a id=\"OpFwidthCoarse\"></a><strong>OpFwidthCoarse</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdxCoarse\"><strong>OpDPdxCoarse</strong></a> and <a href=\"#OpDPdyCoarse\"><strong>OpDPdyCoarse</strong></a> on <em>P</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>P</em> must be the same as <em>Result Type</em>. <em>P</em> is the value to take the derivative of.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpFwidthCoarse\n\nResult is the same as computing the sum of the absolute values of OpDPdxCoarse and OpDPdyCoarse on P.\n\n Result Type must be a scalar or vector of floating-point type. \n\n The type of P must be the same as Result Type. P is the value to take the derivative of.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Derivative",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 215,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "P",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpPhi",
    "Description": "<a id=\"OpPhi\"></a><strong>OpPhi</strong><br />\n<br />\nThe SSA phi function.<br />\n<br />\nThe result is selected based on control flow: If control reached the current block from <em>Parent i</em>, <em>Result Id</em> gets the value that <em>Variable i</em> had at the end of <em>Parent i</em>.<br />\n<br />\n<em>Result Type</em> can be any type.<br />\n<br />\nOperands are a sequence of pairs: (<em>Variable 1</em>, <em>Parent 1</em> block), (<em>Variable 2</em>, <em>Parent 2</em> block), &#8230; Each <em>Parent i</em> block is the label of an immediate predecessor in the CFG of the current block. A <em>Parent i</em> block must not appear more than once in the operand sequence. All <em>Variables</em> must have a type matching <em>Result Type</em>.<br />\n<br />\nWithin a block, this instruction must appear before all non-<strong>OpPhi</strong> instructions (except for <a href=\"#OpLine\"><strong>OpLine</strong></a>, which can be mixed with <strong>OpPhi</strong>).",
    "DescriptionPlain": "OpPhi\n\nThe SSA phi function.\n\nThe result is selected based on control flow: If control reached the current block from Parent i, Result Id gets the value that Variable i had at the end of Parent i.\n\nResult Type can be any type.\n\nOperands are a sequence of pairs: (Variable 1, Parent 1 block), (Variable 2, Parent 2 block), &#8230; Each Parent i block is the label of an immediate predecessor in the CFG of the current block. A Parent i block must not appear more than once in the operand sequence. All Variables must have a type matching Result Type.\n\nWithin a block, this instruction must appear before all non-OpPhi instructions (except for OpLine, which can be mixed with OpPhi).",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 245,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Variables",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpLoopMerge",
    "Description": "<a id=\"OpLoopMerge\"></a><strong>OpLoopMerge</strong><br />\n<br />\nDeclare a structured loop.<br />\n<br />\nThis instruction must immediately precede either an <a href=\"#OpBranch\"><strong>OpBranch</strong></a> or <a href=\"#OpBranchConditional\"><strong>OpBranchConditional</strong></a> instruction. That is, it must be the second-to-last instruction in its block.<br />\n<br />\n<em>Merge Block</em> is the label of the merge block for this structured loop.<br />\n<br />\n<em>Continue Target</em> is the label of a block targeted for processing a loop \"continue\".<br />\n<br />\n<em>Loop Control Parameters</em> appear in <a href=\"#Loop_Control\">Loop Control</a>-table order for any <em>Loop Control</em> setting that requires such a parameter.<br />\n<br />\nSee <a href=\"#StructuredControlFlow\">Structured Control Flow</a> for more detail.",
    "DescriptionPlain": "OpLoopMerge\n\nDeclare a structured loop.\n\nThis instruction must immediately precede either an OpBranch or OpBranchConditional instruction. That is, it must be the second-to-last instruction in its block.\n\nMerge Block is the label of the merge block for this structured loop.\n\nContinue Target is the label of a block targeted for processing a loop \"continue\".\n\nLoop Control Parameters appear in Loop Control-table order for any Loop Control setting that requires such a parameter.\n\nSee Structured Control Flow for more detail.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 246,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "MergeBlock",
        "Type": "ID"
      },
      {
        "Name": "ContinueTarget",
        "Type": "ID"
      },
      {
        "Name": "LoopControl",
        "Type": "LoopControl"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpSelectionMerge",
    "Description": "<a id=\"OpSelectionMerge\"></a><strong>OpSelectionMerge</strong><br />\n<br />\nDeclare a structured selection.<br />\n<br />\nThis instruction must immediately precede either an <a href=\"#OpBranchConditional\"><strong>OpBranchConditional</strong></a> or <a href=\"#OpSwitch\"><strong>OpSwitch</strong></a> instruction. That is, it must be the second-to-last instruction in its block.<br />\n<br />\n<em>Merge Block</em> is the label of the merge block for this structured selection.<br />\n<br />\nSee <a href=\"#StructuredControlFlow\">Structured Control Flow</a> for more detail.",
    "DescriptionPlain": "OpSelectionMerge\n\nDeclare a structured selection.\n\nThis instruction must immediately precede either an OpBranchConditional or OpSwitch instruction. That is, it must be the second-to-last instruction in its block.\n\nMerge Block is the label of the merge block for this structured selection.\n\nSee Structured Control Flow for more detail.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 247,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "MergeBlock",
        "Type": "ID"
      },
      {
        "Name": "SelectionControl",
        "Type": "SelectionControl"
      }
    ]
  },
  {
    "Name": "OpLabel",
    "Description": "<a id=\"OpLabel\"></a><strong>OpLabel</strong><br />\n<br />\nThe block label instruction: Any reference to a block is through the <em>Result &lt;id&gt;</em> of its label.<br />\n<br />\nMust be the first instruction of any block, and appears only as the first instruction of a block.",
    "DescriptionPlain": "OpLabel\n\nThe block label instruction: Any reference to a block is through the Result &lt;id&gt; of its label.\n\nMust be the first instruction of any block, and appears only as the first instruction of a block.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 248,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBranch",
    "Description": "<a id=\"OpBranch\"></a><strong>OpBranch</strong><br />\n<br />\nUnconditional branch to <em>Target Label</em>.<br />\n<br />\n<em>Target Label</em> must be the <em>Result &lt;id&gt;</em> of an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> instruction in the current function.<br />\n<br />\nThis instruction must be the last instruction in a block.",
    "DescriptionPlain": "OpBranch\n\nUnconditional branch to Target Label.\n\nTarget Label must be the Result &lt;id&gt; of an OpLabel instruction in the current function.\n\nThis instruction must be the last instruction in a block.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 249,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "TargetLabel",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBranchConditional",
    "Description": "<a id=\"OpBranchConditional\"></a><strong>OpBranchConditional</strong><br />\n<br />\nIf <em>Condition</em> is <strong>true</strong>, branch to <em>True Label</em>, otherwise branch to <em>False Label</em>.<br />\n<br />\n<em>Condition</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar.<br />\n<br />\n<em>True Label</em> must be an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> in the current function.<br />\n<br />\n<em>False Label</em> must be an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> in the current function.<br />\n<br />\n<em>Branch weights</em> are unsigned 32-bit integer literals. There must be either no <em>Branch Weights</em> or exactly two branch weights. If present, the first is the weight for branching to <em>True Label</em>, and the second is the weight for branching to <em>False Label</em>. The implied probability that a branch is taken is its weight divided by the sum of the two <em>Branch weights</em>.<br />\n<br />\nThis instruction must be the last instruction in a block.",
    "DescriptionPlain": "OpBranchConditional\n\nIf Condition is true, branch to True Label, otherwise branch to False Label.\n\nCondition must be a Boolean type scalar.\n\nTrue Label must be an OpLabel in the current function.\n\nFalse Label must be an OpLabel in the current function.\n\nBranch weights are unsigned 32-bit integer literals. There must be either no Branch Weights or exactly two branch weights. If present, the first is the weight for branching to True Label, and the second is the weight for branching to False Label. The implied probability that a branch is taken is its weight divided by the sum of the two Branch weights.\n\nThis instruction must be the last instruction in a block.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "4 + variable",
    "WordCountFix": 4,
    "OpCode": 250,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Condition",
        "Type": "ID"
      },
      {
        "Name": "TrueLabel",
        "Type": "ID"
      },
      {
        "Name": "FalseLabel",
        "Type": "ID"
      },
      {
        "Name": null,
        "Type": null
      }
    ]
  },
  {
    "Name": "OpSwitch",
    "Description": "<a id=\"OpSwitch\"></a><strong>OpSwitch</strong><br />\n<br />\nMulti-way branch to one of the operand label <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Selector</em> must have a type of <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>. <em>Selector</em> will be compared for equality to the <em>Target</em> literals.<br />\n<br />\n<em>Default</em> must be the <em>&lt;id&gt;</em> of a label.  If <em>Selector</em> does not equal any of the <em>Target</em> literals, control flow will branch to the <em>Default</em> label <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Target</em> must be alternating scalar integer <em>literals</em> and the <em>&lt;id&gt;</em> of a label.  If <em>Selector</em> equals a <em>literal</em>, control flow will branch to the following <em>label &lt;id&gt;</em>. It is invalid for any two <em>literal</em> to be equal to each other. If <em>Selector</em> does not equal any <em>literal</em>, control flow will branch to the <em>Default</em> label <em>&lt;id&gt;</em>. Each <em>literal</em> is interpreted with the type of <em>Selector</em>: The bit width of <em>Selector&#8217;s</em> type will be the width of each <em>literal&#8217;s</em> type. If this width is not a multiple of 32-bits, the literals must be sign extended when the <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> <em>Signedness</em> is set to 1. (See <a href=\"#Literal_Number\"><em>Literal Number</em></a>.)<br />\n<br />\nThis instruction must be the last instruction in a block.",
    "DescriptionPlain": "OpSwitch\n\nMulti-way branch to one of the operand label &lt;id&gt;.\n\nSelector must have a type of OpTypeInt. Selector will be compared for equality to the Target literals.\n\nDefault must be the &lt;id&gt; of a label.  If Selector does not equal any of the Target literals, control flow will branch to the Default label &lt;id&gt;.\n\nTarget must be alternating scalar integer literals and the &lt;id&gt; of a label.  If Selector equals a literal, control flow will branch to the following label &lt;id&gt;. It is invalid for any two literal to be equal to each other. If Selector does not equal any literal, control flow will branch to the Default label &lt;id&gt;. Each literal is interpreted with the type of Selector: The bit width of Selector&#8217;s type will be the width of each literal&#8217;s type. If this width is not a multiple of 32-bits, the literals must be sign extended when the OpTypeInt Signedness is set to 1. (See Literal Number.)\n\nThis instruction must be the last instruction in a block.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "3 + variable",
    "WordCountFix": 3,
    "OpCode": 251,
    "HasVariableWordCount": true,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Selector",
        "Type": "ID"
      },
      {
        "Name": "Default",
        "Type": "ID"
      },
      {
        "Name": "Target",
        "Type": "Pair<LiteralNumber,ID>[]"
      }
    ]
  },
  {
    "Name": "OpKill",
    "Description": "<a id=\"OpKill\"></a><strong>OpKill</strong><br />\n<br />\nFragment-shader discard.<br />\n<br />\nCeases all further processing in any <a href=\"#Invocation\">invocation</a> that executes it: Only instructions these invocations executed before <strong>OpKill</strong> will have observable side effects. If this instruction is executed in non-<a href=\"#UniformControlFlow\">uniform control flow</a>, all subsequent control flow is non-uniform (for invocations that continue to execute).<br />\n<br />\nThis instruction must be the last instruction in a block.<br />\n<br />\nThis instruction is only valid in the <strong>Fragment</strong> <a href=\"#Execution_Model\">Execution Model</a>.",
    "DescriptionPlain": "OpKill\n\nFragment-shader discard.\n\nCeases all further processing in any invocation that executes it: Only instructions these invocations executed before OpKill will have observable side effects. If this instruction is executed in non-uniform control flow, all subsequent control flow is non-uniform (for invocations that continue to execute).\n\nThis instruction must be the last instruction in a block.\n\nThis instruction is only valid in the Fragment Execution Model.",
    "Category": "Control-Flow",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "1",
    "WordCountFix": 1,
    "OpCode": 252,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": []
  },
  {
    "Name": "OpReturn",
    "Description": "<a id=\"OpReturn\"></a><strong>OpReturn</strong><br />\n<br />\nReturn with no value from a function with void return type.<br />\n<br />\nThis instruction must be the last instruction in a block.",
    "DescriptionPlain": "OpReturn\n\nReturn with no value from a function with void return type.\n\nThis instruction must be the last instruction in a block.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "1",
    "WordCountFix": 1,
    "OpCode": 253,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": []
  },
  {
    "Name": "OpReturnValue",
    "Description": "<a id=\"OpReturnValue\"></a><strong>OpReturnValue</strong><br />\n<br />\nReturn a value from a function.<br />\n<br />\n<em>Value</em> is the value returned, by copy, and must match the <em>Return Type</em> operand of the <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> type of the <a href=\"#OpFunction\"><strong>OpFunction</strong></a> body this return instruction is in.<br />\n<br />\nThis instruction must be the last instruction in a block.",
    "DescriptionPlain": "OpReturnValue\n\nReturn a value from a function.\n\nValue is the value returned, by copy, and must match the Return Type operand of the OpTypeFunction type of the OpFunction body this return instruction is in.\n\nThis instruction must be the last instruction in a block.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 254,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpUnreachable",
    "Description": "<a id=\"OpUnreachable\"></a><strong>OpUnreachable</strong><br />\n<br />\nDeclares that this block is not reachable in the CFG.<br />\n<br />\nThis instruction must be the last instruction in a block.",
    "DescriptionPlain": "OpUnreachable\n\nDeclares that this block is not reachable in the CFG.\n\nThis instruction must be the last instruction in a block.",
    "Category": "Control-Flow",
    "Capabilities": [],
    "WordCount": "1",
    "WordCountFix": 1,
    "OpCode": 255,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": []
  },
  {
    "Name": "OpLifetimeStart",
    "Description": "<a id=\"OpLifetimeStart\"></a><strong>OpLifetimeStart</strong><br />\n<br />\nDeclare that an object was not defined before this instruction.<br />\n<br />\n<em>Pointer</em> is a pointer to the object whose lifetime is starting. Its type must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage_Class\">Storage Class</a> <strong>Function</strong>.<br />\n<br />\n<em>Size</em> must be 0 if <em>Pointer</em> is a pointer to a non-void type or the <strong>Addresses</strong> <a href=\"#Capability\">capability</a> is not being used. If <em>Size</em> is non-zero, it is the number of bytes of memory whose lifetime is starting.  Its type  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It is treated as unsigned; if its type has <em>Signedness</em> of 1, its sign bit cannot be set.",
    "DescriptionPlain": "OpLifetimeStart\n\nDeclare that an object was not defined before this instruction.\n\nPointer is a pointer to the object whose lifetime is starting. Its type must be an OpTypePointer with Storage Class Function.\n\nSize must be 0 if Pointer is a pointer to a non-void type or the Addresses capability is not being used. If Size is non-zero, it is the number of bytes of memory whose lifetime is starting.  Its type  must be an integer type scalar.  It is treated as unsigned; if its type has Signedness of 1, its sign bit cannot be set.",
    "Category": "Control-Flow",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 256,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "Size",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpLifetimeStop",
    "Description": "<a id=\"OpLifetimeStop\"></a><strong>OpLifetimeStop</strong><br />\n<br />\nDeclare that an object is dead after this instruction.<br />\n<br />\n<em>Pointer</em> is a pointer to the object whose lifetime is ending. Its type must be an <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage_Class\">Storage Class</a> <strong>Function</strong>.<br />\n<br />\n<em>Size</em> must be 0 if <em>Pointer</em> is a pointer to a non-void type or the <strong>Addresses</strong> <a href=\"#Capability\">capability</a> is not being used. If <em>Size</em> is non-zero, it is the number of bytes of memory whose lifetime is ending.  Its type  must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  It is treated as unsigned; if its type has <em>Signedness</em> of 1, its sign bit cannot be set.",
    "DescriptionPlain": "OpLifetimeStop\n\nDeclare that an object is dead after this instruction.\n\nPointer is a pointer to the object whose lifetime is ending. Its type must be an OpTypePointer with Storage Class Function.\n\nSize must be 0 if Pointer is a pointer to a non-void type or the Addresses capability is not being used. If Size is non-zero, it is the number of bytes of memory whose lifetime is ending.  Its type  must be an integer type scalar.  It is treated as unsigned; if its type has Signedness of 1, its sign bit cannot be set.",
    "Category": "Control-Flow",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 257,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "Size",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpAtomicLoad",
    "Description": "<a id=\"OpAtomicLoad\"></a><strong>OpAtomicLoad</strong><br />\n<br />\nAtomically load through <em>Pointer</em> using the given <em>Semantics</em>. All subparts of the value that is loaded will be read atomically with respect to all other atomic accesses to it within <em>Scope</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Pointer</em> is the pointer to the memory to read. The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicLoad\n\nAtomically load through Pointer using the given Semantics. All subparts of the value that is loaded will be read atomically with respect to all other atomic accesses to it within Scope.\n\n Result Type must be a scalar of integer type or floating-point type. \n\nPointer is the pointer to the memory to read. The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 227,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicStore",
    "Description": "<a id=\"OpAtomicStore\"></a><strong>OpAtomicStore</strong><br />\n<br />\nAtomically store through <em>Pointer</em> using the given <em>Semantics</em>. All subparts of <em>Value</em> will be written atomically with respect to all other atomic accesses to it within <em>Scope</em>.<br />\n<br />\n<em>Pointer</em> is the pointer to the memory to write. The type it points to  must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n<em>Value</em> is the value to write. The type of <em>Value</em> and the type pointed to by <em>Pointer</em> must be the same type.",
    "DescriptionPlain": "OpAtomicStore\n\nAtomically store through Pointer using the given Semantics. All subparts of Value will be written atomically with respect to all other atomic accesses to it within Scope.\n\nPointer is the pointer to the memory to write. The type it points to  must be a scalar of integer type or floating-point type. \n\nValue is the value to write. The type of Value and the type pointed to by Pointer must be the same type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 228,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicExchange",
    "Description": "<a id=\"OpAtomicExchange\"></a><strong>OpAtomicExchange</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> from copying <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar of <a href=\"#Integer\"><em>integer type</em></a> or <a href=\"#Floating\"><em>floating-point type</em></a>. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicExchange\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value from copying Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be a scalar of integer type or floating-point type. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 229,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicCompareExchange",
    "Description": "<a id=\"OpAtomicCompareExchange\"></a><strong>OpAtomicCompareExchange</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by selecting <em>Value</em> if <em>Original Value</em> equals <em>Comparator</em> or selecting <em>Original Value</em> otherwise, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\nUse <em>Equal</em> for the memory semantics of this instruction when <em>Value</em> and <em>Original Value</em> compare equal.<br />\n<br />\nUse <em>Unequal</em> for the memory semantics of this instruction when <em>Value</em> and <em>Original Value</em> compare unequal. <em>Unequal</em> cannot be set to <strong>Release</strong> or <strong>Acquire and Release</strong>. In addition, <em>Unequal</em> cannot be set to a stronger memory-order then <em>Equal</em>.<br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.  This type must also match the type of <em>Comparator</em>.",
    "DescriptionPlain": "OpAtomicCompareExchange\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by selecting Value if Original Value equals Comparator or selecting Original Value otherwise, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\nUse Equal for the memory semantics of this instruction when Value and Original Value compare equal.\n\nUse Unequal for the memory semantics of this instruction when Value and Original Value compare unequal. Unequal cannot be set to Release or Acquire and Release. In addition, Unequal cannot be set to a stronger memory-order then Equal.\n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.  This type must also match the type of Comparator.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "9",
    "WordCountFix": 9,
    "OpCode": 230,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsEqual",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsUnequal",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      },
      {
        "Name": "Comparator",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicCompareExchangeWeak",
    "Description": "<a id=\"OpAtomicCompareExchangeWeak\"></a><strong>OpAtomicCompareExchangeWeak</strong><br />\n<br />\nAttempts to do the following:<br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by selecting <em>Value</em> if <em>Original Value</em> equals <em>Comparator</em> or selecting <em>Original Value</em> otherwise, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\nThe weak compare-and-exchange operations may fail spuriously. That is, even when <em>Original Value</em> equals <em>Comparator</em> the comparison can fail and store back the <em>Original Value</em> through <em>Pointer</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\nUse <em>Equal</em> for the memory semantics of this instruction when <em>Value</em> and <em>Original Value</em> compare equal.<br />\n<br />\nUse <em>Unequal</em> for the memory semantics of this instruction when <em>Value</em> and <em>Original Value</em> compare unequal. <em>Unequal</em> cannot be set to <strong>Release</strong> or <strong>Acquire and Release</strong>. In addition, <em>Unequal</em> cannot be set to a stronger memory-order then <em>Equal</em>.<br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.  This type must also match the type of <em>Comparator</em>.",
    "DescriptionPlain": "OpAtomicCompareExchangeWeak\n\nAttempts to do the following:\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by selecting Value if Original Value equals Comparator or selecting Original Value otherwise, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nThe weak compare-and-exchange operations may fail spuriously. That is, even when Original Value equals Comparator the comparison can fail and store back the Original Value through Pointer.\n\n Result Type must be an integer type scalar. \n\nUse Equal for the memory semantics of this instruction when Value and Original Value compare equal.\n\nUse Unequal for the memory semantics of this instruction when Value and Original Value compare unequal. Unequal cannot be set to Release or Acquire and Release. In addition, Unequal cannot be set to a stronger memory-order then Equal.\n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.  This type must also match the type of Comparator.",
    "Category": "Atomic",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "9",
    "WordCountFix": 9,
    "OpCode": 231,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsEqual",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsUnequal",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      },
      {
        "Name": "Comparator",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicIIncrement",
    "Description": "<a id=\"OpAtomicIIncrement\"></a><strong>OpAtomicIIncrement</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> through integer addition of <em>1</em> to <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicIIncrement\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value through integer addition of 1 to Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 232,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicIDecrement",
    "Description": "<a id=\"OpAtomicIDecrement\"></a><strong>OpAtomicIDecrement</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> through integer subtraction of <em>1</em> from <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicIDecrement\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value through integer subtraction of 1 from Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 233,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicIAdd",
    "Description": "<a id=\"OpAtomicIAdd\"></a><strong>OpAtomicIAdd</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by integer addition of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicIAdd\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by integer addition of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 234,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicISub",
    "Description": "<a id=\"OpAtomicISub\"></a><strong>OpAtomicISub</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by integer subtraction of <em>Value</em> from <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicISub\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by integer subtraction of Value from Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 235,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicSMin",
    "Description": "<a id=\"OpAtomicSMin\"></a><strong>OpAtomicSMin</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the smallest signed integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicSMin\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the smallest signed integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 236,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicUMin",
    "Description": "<a id=\"OpAtomicUMin\"></a><strong>OpAtomicUMin</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the smallest unsigned integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicUMin\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the smallest unsigned integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 237,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicSMax",
    "Description": "<a id=\"OpAtomicSMax\"></a><strong>OpAtomicSMax</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the largest signed integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicSMax\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the largest signed integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 238,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicUMax",
    "Description": "<a id=\"OpAtomicUMax\"></a><strong>OpAtomicUMax</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the largest unsigned integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicUMax\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the largest unsigned integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 239,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicAnd",
    "Description": "<a id=\"OpAtomicAnd\"></a><strong>OpAtomicAnd</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise AND of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicAnd\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise AND of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 240,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicOr",
    "Description": "<a id=\"OpAtomicOr\"></a><strong>OpAtomicOr</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise OR of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicOr\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise OR of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 241,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicXor",
    "Description": "<a id=\"OpAtomicXor\"></a><strong>OpAtomicXor</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise exclusive OR of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n <em>Result Type</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar. <br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>.  The type of the value pointed to by <em>Pointer</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpAtomicXor\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise exclusive OR of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\n Result Type must be an integer type scalar. \n\n The type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.",
    "Category": "Atomic",
    "Capabilities": [],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 242,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicFlagTestAndSet",
    "Description": "<a id=\"OpAtomicFlagTestAndSet\"></a><strong>OpAtomicFlagTestAndSet</strong><br />\n<br />\nAtomically sets the flag value pointed to by <em>Pointer</em> to the set state.<br />\n<br />\n<em>Pointer</em> must be a pointer to a 32-bit integer type representing an atomic flag.<br />\n<br />\nThe instruction&#8217;s result is true if the flag was in the set state or false if the flag was in the clear state immediately before the operation.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\nResults are undefined if an atomic flag is modified  by an instruction other than <a href=\"#OpAtomicFlagTestAndSet\"><strong>OpAtomicFlagTestAndSet</strong></a> or <a href=\"#OpAtomicFlagClear\"><strong>OpAtomicFlagClear</strong></a>",
    "DescriptionPlain": "OpAtomicFlagTestAndSet\n\nAtomically sets the flag value pointed to by Pointer to the set state.\n\nPointer must be a pointer to a 32-bit integer type representing an atomic flag.\n\nThe instruction&#8217;s result is true if the flag was in the set state or false if the flag was in the clear state immediately before the operation.\n\nResult Type must be a Boolean type.\n\nResults are undefined if an atomic flag is modified  by an instruction other than OpAtomicFlagTestAndSet or OpAtomicFlagClear",
    "Category": "Atomic",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 318,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpAtomicFlagClear",
    "Description": "<a id=\"OpAtomicFlagClear\"></a><strong>OpAtomicFlagClear</strong><br />\n<br />\nAtomically sets the flag value pointed to by <em>Pointer</em> to the clear state.<br />\n<br />\n<em>Pointer</em> must be a pointer to a 32-bit integer type representing an atomic flag.<br />\n<br />\nMemory Semantics cannot be <a href=\"#Memory_Semantics\"><strong>Acquire</strong></a> or <a href=\"#Memory_Semantics\"><strong>AcquireRelease</strong></a><br />\n<br />\nResults are undefined if an atomic flag is modified  by an instruction other than <a href=\"#OpAtomicFlagTestAndSet\"><strong>OpAtomicFlagTestAndSet</strong></a> or <a href=\"#OpAtomicFlagClear\"><strong>OpAtomicFlagClear</strong></a>",
    "DescriptionPlain": "OpAtomicFlagClear\n\nAtomically sets the flag value pointed to by Pointer to the clear state.\n\nPointer must be a pointer to a 32-bit integer type representing an atomic flag.\n\nMemory Semantics cannot be Acquire or AcquireRelease\n\nResults are undefined if an atomic flag is modified  by an instruction other than OpAtomicFlagTestAndSet or OpAtomicFlagClear",
    "Category": "Atomic",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 319,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "ScopeScope",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpEmitVertex",
    "Description": "<a id=\"OpEmitVertex\"></a><strong>OpEmitVertex</strong><br />\n<br />\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.<br />\n<br />\nThis instruction can only be used when only one stream is present.",
    "DescriptionPlain": "OpEmitVertex\n\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.\n\nThis instruction can only be used when only one stream is present.",
    "Category": "Primitive",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "1",
    "WordCountFix": 1,
    "OpCode": 218,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": []
  },
  {
    "Name": "OpEndPrimitive",
    "Description": "<a id=\"OpEndPrimitive\"></a><strong>OpEndPrimitive</strong><br />\n<br />\nFinish the current primitive and start a new one.  No vertex is emitted.<br />\n<br />\nThis instruction can only be used when only one stream is present.",
    "DescriptionPlain": "OpEndPrimitive\n\nFinish the current primitive and start a new one.  No vertex is emitted.\n\nThis instruction can only be used when only one stream is present.",
    "Category": "Primitive",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "1",
    "WordCountFix": 1,
    "OpCode": 219,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": []
  },
  {
    "Name": "OpEmitStreamVertex",
    "Description": "<a id=\"OpEmitStreamVertex\"></a><strong>OpEmitStreamVertex</strong><br />\n<br />\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.<br />\n<br />\n<em>Stream</em> must be an <em>&lt;id&gt;</em> of a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> with a scalar integer type. That constant is the output-primitive stream number.<br />\n<br />\nThis instruction can only be used when multiple streams are present.",
    "DescriptionPlain": "OpEmitStreamVertex\n\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.\n\nStream must be an &lt;id&gt; of a constant instruction with a scalar integer type. That constant is the output-primitive stream number.\n\nThis instruction can only be used when multiple streams are present.",
    "Category": "Primitive",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 220,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Stream",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpEndStreamPrimitive",
    "Description": "<a id=\"OpEndStreamPrimitive\"></a><strong>OpEndStreamPrimitive</strong><br />\n<br />\nFinish the current primitive and start a new one.  No vertex is emitted.<br />\n<br />\n<em>Stream</em> must be an <em>&lt;id&gt;</em> of a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> with a scalar integer type. That constant is the output-primitive stream number.<br />\n<br />\nThis instruction can only be used when multiple streams are present.",
    "DescriptionPlain": "OpEndStreamPrimitive\n\nFinish the current primitive and start a new one.  No vertex is emitted.\n\nStream must be an &lt;id&gt; of a constant instruction with a scalar integer type. That constant is the output-primitive stream number.\n\nThis instruction can only be used when multiple streams are present.",
    "Category": "Primitive",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 221,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Stream",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpControlBarrier",
    "Description": "<a id=\"OpControlBarrier\"></a><strong>OpControlBarrier</strong><br />\n<br />\nWait for other invocations of this module to reach the current point of execution.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> scope must reach this point of execution before any invocation will proceed beyond it.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\nIf <em>Semantics</em> is not <strong>None</strong>, this instruction also serves as an <a href=\"#OpMemoryBarrier\"><strong>OpMemoryBarrier</strong></a> instruction, and must also perform and adhere to the description and semantics of an <strong>OpMemoryBarrier</strong> instruction with the same <em>Memory</em> and <em>Semantics</em> operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If <em>Semantics</em> is <strong>None</strong>, <em>Memory</em> is ignored.<br />\n<br />\nIt is only valid to use this instruction with <strong>TessellationControl</strong>, <strong>GLCompute</strong>, or <strong>Kernel</strong> <a href=\"#Execution_Model\">execution models</a>.<br />\n<br />\nWhen used with the <strong>TessellationControl</strong> <a href=\"#Execution_Model\">execution model</a>, it also implicitly synchronizes the <strong>Output</strong> <a href=\"#Storage_Class\">Storage Class</a>:  Writes to <strong>Output</strong> variables performed by any invocation executed prior to a <strong>OpControlBarrier</strong> will be visible to any other invocation after return from that <strong>OpControlBarrier</strong>.",
    "DescriptionPlain": "OpControlBarrier\n\nWait for other invocations of this module to reach the current point of execution.\n\nAll invocations of this module within Execution scope must reach this point of execution before any invocation will proceed beyond it.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nIf Semantics is not None, this instruction also serves as an OpMemoryBarrier instruction, and must also perform and adhere to the description and semantics of an OpMemoryBarrier instruction with the same Memory and Semantics operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If Semantics is None, Memory is ignored.\n\nIt is only valid to use this instruction with TessellationControl, GLCompute, or Kernel execution models.\n\nWhen used with the TessellationControl execution model, it also implicitly synchronizes the Output Storage Class:  Writes to Output variables performed by any invocation executed prior to a OpControlBarrier will be visible to any other invocation after return from that OpControlBarrier.",
    "Category": "Barrier",
    "Capabilities": [],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 224,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "ScopeMemory",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpMemoryBarrier",
    "Description": "<a id=\"OpMemoryBarrier\"></a><strong>OpMemoryBarrier</strong><br />\n<br />\nControl the order that memory accesses are observed.<br />\n<br />\nEnsures that memory accesses issued before this instruction will be observed before memory accesses issued after this instruction. This control is ensured only for memory accesses issued by this <a href=\"#Invocation\">invocation</a> and observed by another invocation executing within <em>Memory</em> scope.<br />\n<br />\n<em>Semantics</em> declares what kind of memory is being controlled and what kind of control to apply.<br />\n<br />\nTo execute both a memory barrier and a control barrier, see <a href=\"#OpControlBarrier\"><strong>OpControlBarrier</strong></a>.",
    "DescriptionPlain": "OpMemoryBarrier\n\nControl the order that memory accesses are observed.\n\nEnsures that memory accesses issued before this instruction will be observed before memory accesses issued after this instruction. This control is ensured only for memory accesses issued by this invocation and observed by another invocation executing within Memory scope.\n\nSemantics declares what kind of memory is being controlled and what kind of control to apply.\n\nTo execute both a memory barrier and a control barrier, see OpControlBarrier.",
    "Category": "Barrier",
    "Capabilities": [],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 225,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "ScopeMemory",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpNamedBarrierInitialize",
    "Description": "<a id=\"OpNamedBarrierInitialize\"></a><strong>OpNamedBarrierInitialize</strong><br />\n<br />\nDeclare a new named-barrier object.<br />\n<br />\n<em>Result Type</em> must be the type <a href=\"#OpTypeNamedBarrier\"><strong>OpTypeNamedBarrier</strong></a>.<br />\n<br />\n<em>Subgroup Count</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar representing the number of subgroups that must reach the current point of execution.",
    "DescriptionPlain": "OpNamedBarrierInitialize\n\nDeclare a new named-barrier object.\n\nResult Type must be the type OpTypeNamedBarrier.\n\nSubgroup Count must be a 32-bit integer type scalar representing the number of subgroups that must reach the current point of execution.",
    "Category": "Barrier",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 328,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SubgroupCount",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpMemoryNamedBarrier",
    "Description": "<a id=\"OpMemoryNamedBarrier\"></a><strong>OpMemoryNamedBarrier</strong><br />\n<br />\nWait for other invocations of this module to reach the current point of execution.<br />\n<br />\n<em>Named Barrier</em> must be the type <a href=\"#OpTypeNamedBarrier\"><strong>OpTypeNamedBarrier</strong></a>.<br />\n<br />\nIf <em>Semantics</em> is not <strong>None</strong>, this instruction also serves as an <a href=\"#OpMemoryBarrier\"><strong>OpMemoryBarrier</strong></a> instruction, and must also perform and adhere to the description and semantics of an <strong>OpMemoryBarrier</strong> instruction with the same <em>Memory</em> and <em>Semantics</em> operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If <em>Semantics</em> <strong>None</strong>, <em>Memory</em> is ignored.",
    "DescriptionPlain": "OpMemoryNamedBarrier\n\nWait for other invocations of this module to reach the current point of execution.\n\nNamed Barrier must be the type OpTypeNamedBarrier.\n\nIf Semantics is not None, this instruction also serves as an OpMemoryBarrier instruction, and must also perform and adhere to the description and semantics of an OpMemoryBarrier instruction with the same Memory and Semantics operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If Semantics None, Memory is ignored.",
    "Category": "Barrier",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 329,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "NamedBarrier",
        "Type": "ID"
      },
      {
        "Name": "ScopeMemory",
        "Type": "ID"
      },
      {
        "Name": "MemorySemanticsSemantics",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupAsyncCopy",
    "Description": "<a id=\"OpGroupAsyncCopy\"></a><strong>OpGroupAsyncCopy</strong><br />\n<br />\nPerform an asynchronous group copy of <em>Num Elements</em> elements from <em>Source</em> to <em>Destination</em>. The asynchronous copy is performed by all work-items in a group.<br />\n<br />\nThis instruction returns an event object that can be used by <a href=\"#OpGroupWaitEvents\"><strong>OpGroupWaitEvents</strong></a> to wait for the async copy to finish.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeEvent\"><strong>OpTypeEvent</strong></a> object.<br />\n<br />\n<em>Destination</em> must be a pointer to a scalar or vector of <a href=\"#Floating\"><em>floating-point type</em></a> or <a href=\"#Integer\"><em>integer type</em></a>. <br />\n<br />\n<em>Destination</em> pointer <a href=\"#Storage_Class\">Storage Class</a> must be <strong>Workgroup</strong> or <strong>CrossWorkgroup</strong>.<br />\n<br />\n The type of <em>Source</em> must be the same as <em>Destination</em>. <br />\n<br />\nWhen <em>Destination</em> pointer <a href=\"#Storage_Class\">Storage Class</a> is <strong>Workgroup</strong>, the <em>Source</em> pointer Storage Class must be <strong>CrossWorkgroup</strong>. In this case <em>Stride</em> defines the stride in elements when reading from <em>Source</em> pointer.<br />\n<br />\nWhen <em>Destination</em> pointer <a href=\"#Storage_Class\">Storage Class</a> is <strong>CrossWorkgroup</strong>, the <em>Source</em> pointer Storage Class must be <strong>Workgroup</strong>. In this case <em>Stride</em> defines the stride in elements when writing each element to <em>Destination</em> pointer.<br />\n<br />\n<em>Stride</em> and <em>NumElements</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\">addressing model</a> is <em>Physical32</em> and 64 bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <em>Addressing Model</em> is <em>Physical64</em>.<br />\n<br />\n<em>Event</em> must have a type of <a href=\"#OpTypeEvent\"><strong>OpTypeEvent</strong></a>.<br />\n<br />\n<em>Event</em> can be used to associate the copy with a previous copy allowing an event to be shared by multiple copies. Otherwise <em>Event</em> should be an <a href=\"#OpConstantNull\"><strong>OpConstantNull</strong></a>.<br />\n<br />\nIf <em>Event</em> argument is not <a href=\"#OpConstantNull\"><strong>OpConstantNull</strong></a>, the event object supplied in event argument will be returned.",
    "DescriptionPlain": "OpGroupAsyncCopy\n\nPerform an asynchronous group copy of Num Elements elements from Source to Destination. The asynchronous copy is performed by all work-items in a group.\n\nThis instruction returns an event object that can be used by OpGroupWaitEvents to wait for the async copy to finish.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be an OpTypeEvent object.\n\nDestination must be a pointer to a scalar or vector of floating-point type or integer type. \n\nDestination pointer Storage Class must be Workgroup or CrossWorkgroup.\n\n The type of Source must be the same as Destination. \n\nWhen Destination pointer Storage Class is Workgroup, the Source pointer Storage Class must be CrossWorkgroup. In this case Stride defines the stride in elements when reading from Source pointer.\n\nWhen Destination pointer Storage Class is CrossWorkgroup, the Source pointer Storage Class must be Workgroup. In this case Stride defines the stride in elements when writing each element to Destination pointer.\n\nStride and NumElements must be a 32-bit integer type scalar when the addressing model is Physical32 and 64 bit integer type scalar when the Addressing Model is Physical64.\n\nEvent must have a type of OpTypeEvent.\n\nEvent can be used to associate the copy with a previous copy allowing an event to be shared by multiple copies. Otherwise Event should be an OpConstantNull.\n\nIf Event argument is not OpConstantNull, the event object supplied in event argument will be returned.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "9",
    "WordCountFix": 9,
    "OpCode": 259,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Destination",
        "Type": "ID"
      },
      {
        "Name": "Source",
        "Type": "ID"
      },
      {
        "Name": "NumElements",
        "Type": "ID"
      },
      {
        "Name": "Stride",
        "Type": "ID"
      },
      {
        "Name": "Event",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupWaitEvents",
    "Description": "<a id=\"OpGroupWaitEvents\"></a><strong>OpGroupWaitEvents</strong><br />\n<br />\nWait for events generated by <a href=\"#OpGroupAsyncCopy\"><strong>OpGroupAsyncCopy</strong></a> operations to complete. <em>Events List</em> points to <em>Num Events</em> event objects, which will be released after the wait is performed.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Num Events</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Events List</em> must be a pointer to <a href=\"#OpTypeEvent\"><strong>OpTypeEvent</strong></a>.",
    "DescriptionPlain": "OpGroupWaitEvents\n\nWait for events generated by OpGroupAsyncCopy operations to complete. Events List points to Num Events event objects, which will be released after the wait is performed.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nExecution must be Workgroup or Subgroup Scope.\n\nNum Events must be a 32-bit integer type scalar.\n\nEvents List must be a pointer to OpTypeEvent.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 260,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "NumEvents",
        "Type": "ID"
      },
      {
        "Name": "EventsList",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupAll",
    "Description": "<a id=\"OpGroupAll\"></a><strong>OpGroupAll</strong><br />\n<br />\nEvaluates a predicate for all invocations in the group,resulting in <strong>true</strong> if predicate evaluates to <strong>true</strong> for all <a href=\"#Invocation\">invocations</a> in the group, otherwise the result is <strong>false</strong>.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Predicate</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.",
    "DescriptionPlain": "OpGroupAll\n\nEvaluates a predicate for all invocations in the group,resulting in true if predicate evaluates to true for all invocations in the group, otherwise the result is false.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a Boolean type.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPredicate must be a Boolean type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 261,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Predicate",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupAny",
    "Description": "<a id=\"OpGroupAny\"></a><strong>OpGroupAny</strong><br />\n<br />\nEvaluates a predicate for all invocations in the group,resulting in <strong>true</strong> if predicate evaluates to <strong>true</strong> for any <a href=\"#Invocation\">invocation</a> in the group, otherwise the result is <strong>false</strong>.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Predicate</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.",
    "DescriptionPlain": "OpGroupAny\n\nEvaluates a predicate for all invocations in the group,resulting in true if predicate evaluates to true for any invocation in the group, otherwise the result is false.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a Boolean type.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPredicate must be a Boolean type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 262,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Predicate",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupBroadcast",
    "Description": "<a id=\"OpGroupBroadcast\"></a><strong>OpGroupBroadcast</strong><br />\n<br />\nReturn the <em>Value</em> of the <a href=\"#Invocation\">invocation</a> identified by the local id <em>LocalId</em> to all invocations in the group.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> or a 16, 32 or 64 <a href=\"#Float\"><em>float type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>Value</em> must be the same as <em>Result Type</em>. <br />\n<br />\n<em>LocalId</em> must be an integer datatype. It can be a scalar, or a vector with 2 components or a vector with 3 components. <em>LocalId</em> must be the same for all <a href=\"#Invocation\">invocations</a> in the group.",
    "DescriptionPlain": "OpGroupBroadcast\n\nReturn the Value of the invocation identified by the local id LocalId to all invocations in the group.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type or a 16, 32 or 64 float type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of Value must be the same as Result Type. \n\nLocalId must be an integer datatype. It can be a scalar, or a vector with 2 components or a vector with 3 components. LocalId must be the same for all invocations in the group.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 263,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      },
      {
        "Name": "LocalId",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupIAdd",
    "Description": "<a id=\"OpGroupIAdd\"></a><strong>OpGroupIAdd</strong><br />\n<br />\nAn integer add group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is 0.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpGroupIAdd\n\nAn integer add group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is 0.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 264,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Operation",
        "Type": "GroupOperation"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupFAdd",
    "Description": "<a id=\"OpGroupFAdd\"></a><strong>OpGroupFAdd</strong><br />\n<br />\nA floating-point add group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is 0.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 16-bit, 32-bit, or 64-bit <a href=\"#Floating\"><em>floating-point type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpGroupFAdd\n\nA floating-point add group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is 0.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 16-bit, 32-bit, or 64-bit floating-point type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 265,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Operation",
        "Type": "GroupOperation"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupFMin",
    "Description": "<a id=\"OpGroupFMin\"></a><strong>OpGroupFMin</strong><br />\n<br />\nA floating-point minimum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is +INF.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 16-bit, 32-bit, or 64-bit <a href=\"#Floating\"><em>floating-point type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpGroupFMin\n\nA floating-point minimum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is +INF.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 16-bit, 32-bit, or 64-bit floating-point type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 266,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Operation",
        "Type": "GroupOperation"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupUMin",
    "Description": "<a id=\"OpGroupUMin\"></a><strong>OpGroupUMin</strong><br />\n<br />\nAn unsigned integer minimum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is UINT_MAX when <em>X</em> is 32 bits wide and ULONG_MAX when <em>X</em> is 64 bits wide.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpGroupUMin\n\nAn unsigned integer minimum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is UINT_MAX when X is 32 bits wide and ULONG_MAX when X is 64 bits wide.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 267,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Operation",
        "Type": "GroupOperation"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupSMin",
    "Description": "<a id=\"OpGroupSMin\"></a><strong>OpGroupSMin</strong><br />\n<br />\nA signed integer minimum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is INT_MAX when <em>X</em> is 32 bits wide and LONG_MAX when <em>X</em> is 64 bits wide.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpGroupSMin\n\nA signed integer minimum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is INT_MAX when X is 32 bits wide and LONG_MAX when X is 64 bits wide.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 268,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Operation",
        "Type": "GroupOperation"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupFMax",
    "Description": "<a id=\"OpGroupFMax\"></a><strong>OpGroupFMax</strong><br />\n<br />\nA floating-point maximum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is -INF.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 16-bit, 32-bit, or 64-bit <a href=\"#Floating\"><em>floating-point type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpGroupFMax\n\nA floating-point maximum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is -INF.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 16-bit, 32-bit, or 64-bit floating-point type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 269,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Operation",
        "Type": "GroupOperation"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupUMax",
    "Description": "<a id=\"OpGroupUMax\"></a><strong>OpGroupUMax</strong><br />\n<br />\nAn unsigned integer maximum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is 0.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpGroupUMax\n\nAn unsigned integer maximum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is 0.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be a 32-bit or 64-bit integer type scalar.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 270,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Operation",
        "Type": "GroupOperation"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupSMax",
    "Description": "<a id=\"OpGroupSMax\"></a><strong>OpGroupSMax</strong><br />\n<br />\nA signed integer maximum group operation specified for all values of <em>X</em> specified by <a href=\"#Invocation\">invocations</a> in the group.<br />\n<br />\nThe identity <em>I</em> is INT_MIN when <em>X</em> is 32 bits wide and LONG_MIN when <em>X</em> is 64 bits wide.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>X</em> and <em>Result Type</em> must be a 32-bit or 64-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> data type.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n The type of <em>X</em> must be the same as <em>Result Type</em>.",
    "DescriptionPlain": "OpGroupSMax\n\nA signed integer maximum group operation specified for all values of X specified by invocations in the group.\n\nThe identity I is INT_MIN when X is 32 bits wide and LONG_MIN when X is 64 bits wide.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nX and Result Type must be a 32-bit or 64-bit OpTypeInt data type.\n\nExecution must be Workgroup or Subgroup Scope.\n\n The type of X must be the same as Result Type.",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 271,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Operation",
        "Type": "GroupOperation"
      },
      {
        "Name": "X",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSubgroupBallotKHR",
    "Description": "<a id=\"OpSubgroupBallotKHR\"></a><strong>OpSubgroupBallotKHR</strong><br />\n<br />\nSee extension SPV_KHR_shader_ballot",
    "DescriptionPlain": "OpSubgroupBallotKHR\n\nSee extension SPV_KHR_shader_ballot",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 4421,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Predicate",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSubgroupFirstInvocationKHR",
    "Description": "<a id=\"OpSubgroupFirstInvocationKHR\"></a><strong>OpSubgroupFirstInvocationKHR</strong><br />\n<br />\nSee extension SPV_KHR_shader_ballot",
    "DescriptionPlain": "OpSubgroupFirstInvocationKHR\n\nSee extension SPV_KHR_shader_ballot",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 4422,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSubgroupReadInvocationKHR",
    "Description": "<a id=\"OpSubgroupReadInvocationKHR\"></a><strong>OpSubgroupReadInvocationKHR</strong><br />\n<br />\nSee extension SPV_KHR_shader_ballot",
    "DescriptionPlain": "OpSubgroupReadInvocationKHR\n\nSee extension SPV_KHR_shader_ballot",
    "Category": "Group",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 4432,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      },
      {
        "Name": "Index",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpEnqueueMarker",
    "Description": "<a id=\"OpEnqueueMarker\"></a><strong>OpEnqueueMarker</strong><br />\n<br />\nEnqueue a marker command to the queue object specified by <em>Queue</em>. The marker command waits for a list of events to complete, or if the list is empty it waits for all previously enqueued commands in <em>Queue</em> to complete before the marker completes.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.<br />\n<br />\n<em>Queue</em> must be of the type <a href=\"#OpTypeQueue\"><strong>OpTypeQueue</strong></a>.<br />\n<br />\n<em>Num Events</em> specifies the number of event objects in the wait list pointed to by <em>Wait Events</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Wait Events</em> specifies the list of wait event objects and must be a pointer to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.<br />\n<br />\n<em>Ret Event</em> is a pointer to a device event which gets implicitly retained by this instruction.  It must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>. If <em>Ret Event</em> is set to null this instruction becomes a no-op.",
    "DescriptionPlain": "OpEnqueueMarker\n\nEnqueue a marker command to the queue object specified by Queue. The marker command waits for a list of events to complete, or if the list is empty it waits for all previously enqueued commands in Queue to complete before the marker completes.\n\nResult Type must be a 32-bit integer type scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.\n\nQueue must be of the type OpTypeQueue.\n\nNum Events specifies the number of event objects in the wait list pointed to by Wait Events and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nWait Events specifies the list of wait event objects and must be a pointer to OpTypeDeviceEvent.\n\nRet Event is a pointer to a device event which gets implicitly retained by this instruction.  It must have a type of OpTypePointer to OpTypeDeviceEvent. If Ret Event is set to null this instruction becomes a no-op.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 291,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Queue",
        "Type": "ID"
      },
      {
        "Name": "NumEvents",
        "Type": "ID"
      },
      {
        "Name": "WaitEvents",
        "Type": "ID"
      },
      {
        "Name": "RetEvent",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpEnqueueKernel",
    "Description": "<a id=\"OpEnqueueKernel\"></a><strong>OpEnqueueKernel</strong><br />\n<br />\nEnqueue the function specified by <em>Invoke</em> and the NDRange specified by <em>ND Range</em> for execution to the queue object specified by <em>Queue</em>. <br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.<br />\n<br />\n<em>Queue</em> must be of the type <a href=\"#OpTypeQueue\"><strong>OpTypeQueue</strong></a>.<br />\n<br />\n<em>Flags</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  The content of <em>Flags</em> is interpreted as <a href=\"#Kernel_Enqueue_Flags\"><em>Kernel Enqueue Flags</em></a> mask.<br />\n<br />\n<em>ND Range</em> must have a type of <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Num Events</em> specifies the number of event objects in the wait list pointed to by <em>Wait Events</em> and must be 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Wait Events</em> specifies the list of wait event objects and must be a pointer to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.<br />\n<br />\n<em>Ret Event</em> must be a pointer to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> which gets implicitly retained by this instruction. <br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\nEach <em>Local Size</em> operand corresponds (in order) to one <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a> parameter to the <em>Invoke</em> function, and specifies the number of bytes of <strong>Workgroup</strong> storage used to back the pointer during the execution of the <em>Invoke</em> function.",
    "DescriptionPlain": "OpEnqueueKernel\n\nEnqueue the function specified by Invoke and the NDRange specified by ND Range for execution to the queue object specified by Queue. \n\nResult Type must be a 32-bit integer type scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.\n\nQueue must be of the type OpTypeQueue.\n\nFlags must be an integer type scalar.  The content of Flags is interpreted as Kernel Enqueue Flags mask.\n\nND Range must have a type of OpTypeStruct created by OpBuildNDRange.\n\nNum Events specifies the number of event objects in the wait list pointed to by Wait Events and must be 32-bit integer type scalar, which is treated as an unsigned integer.\n\nWait Events specifies the list of wait event objects and must be a pointer to OpTypeDeviceEvent.\n\nRet Event must be a pointer to OpTypeDeviceEvent which gets implicitly retained by this instruction. \n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nEach Local Size operand corresponds (in order) to one OpTypePointer to Workgroup Storage Class parameter to the Invoke function, and specifies the number of bytes of Workgroup storage used to back the pointer during the execution of the Invoke function.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "13 + variable",
    "WordCountFix": 13,
    "OpCode": 292,
    "HasVariableWordCount": true,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Queue",
        "Type": "ID"
      },
      {
        "Name": "Flags",
        "Type": "ID"
      },
      {
        "Name": "NDRange",
        "Type": "ID"
      },
      {
        "Name": "NumEvents",
        "Type": "ID"
      },
      {
        "Name": "WaitEvents",
        "Type": "ID"
      },
      {
        "Name": "RetEvent",
        "Type": "ID"
      },
      {
        "Name": "Invoke",
        "Type": "ID"
      },
      {
        "Name": "Param",
        "Type": "ID"
      },
      {
        "Name": "ParamSize",
        "Type": "ID"
      },
      {
        "Name": "ParamAlign",
        "Type": "ID"
      },
      {
        "Name": "Locals",
        "Type": "ID[]"
      }
    ]
  },
  {
    "Name": "OpGetKernelNDrangeSubGroupCount",
    "Description": "<a id=\"OpGetKernelNDrangeSubGroupCount\"></a><strong>OpGetKernelNDrangeSubGroupCount</strong><br />\n<br />\nReturns the number of subgroups in each workgroup of the dispatch (except for the last in cases where the global size does not divide cleanly into work-groups) given the combination of the passed NDRange descriptor specified by <em>ND Range</em> and the function specified by <em>Invoke</em>.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>ND Range</em> must have a type of <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
    "DescriptionPlain": "OpGetKernelNDrangeSubGroupCount\n\nReturns the number of subgroups in each workgroup of the dispatch (except for the last in cases where the global size does not divide cleanly into work-groups) given the combination of the passed NDRange descriptor specified by ND Range and the function specified by Invoke.\n\nResult Type must be a 32-bit integer type scalar.\n\nND Range must have a type of OpTypeStruct created by OpBuildNDRange.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8",
    "WordCountFix": 8,
    "OpCode": 293,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "NDRange",
        "Type": "ID"
      },
      {
        "Name": "Invoke",
        "Type": "ID"
      },
      {
        "Name": "Param",
        "Type": "ID"
      },
      {
        "Name": "ParamSize",
        "Type": "ID"
      },
      {
        "Name": "ParamAlign",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGetKernelNDrangeMaxSubGroupSize",
    "Description": "<a id=\"OpGetKernelNDrangeMaxSubGroupSize\"></a><strong>OpGetKernelNDrangeMaxSubGroupSize</strong><br />\n<br />\nReturns the maximum sub-group size for the function specified by <em>Invoke</em> and the NDRange specified by <em>ND Range</em>. <br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>ND Range</em> must have a type of <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
    "DescriptionPlain": "OpGetKernelNDrangeMaxSubGroupSize\n\nReturns the maximum sub-group size for the function specified by Invoke and the NDRange specified by ND Range. \n\nResult Type must be a 32-bit integer type scalar.\n\nND Range must have a type of OpTypeStruct created by OpBuildNDRange.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8",
    "WordCountFix": 8,
    "OpCode": 294,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "NDRange",
        "Type": "ID"
      },
      {
        "Name": "Invoke",
        "Type": "ID"
      },
      {
        "Name": "Param",
        "Type": "ID"
      },
      {
        "Name": "ParamSize",
        "Type": "ID"
      },
      {
        "Name": "ParamAlign",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGetKernelWorkGroupSize",
    "Description": "<a id=\"OpGetKernelWorkGroupSize\"></a><strong>OpGetKernelWorkGroupSize</strong><br />\n<br />\nReturns the maximum work-group size that can be used to execute the function specified by <em>Invoke</em> on the device.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
    "DescriptionPlain": "OpGetKernelWorkGroupSize\n\nReturns the maximum work-group size that can be used to execute the function specified by Invoke on the device.\n\nResult Type must be a 32-bit integer type scalar.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 295,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Invoke",
        "Type": "ID"
      },
      {
        "Name": "Param",
        "Type": "ID"
      },
      {
        "Name": "ParamSize",
        "Type": "ID"
      },
      {
        "Name": "ParamAlign",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGetKernelPreferredWorkGroupSizeMultiple",
    "Description": "<a id=\"OpGetKernelPreferredWorkGroupSizeMultiple\"></a><strong>OpGetKernelPreferredWorkGroupSizeMultiple</strong><br />\n<br />\nReturns the preferred multiple of work-group size for the function specified by <em>Invoke</em>. This is a performance hint. Specifying a work-group size that is not a multiple of the value returned by this query as the value of the local work size will not fail to enqueue <em>Invoke</em> for execution unless the work-group size specified is larger than the device maximum.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
    "DescriptionPlain": "OpGetKernelPreferredWorkGroupSizeMultiple\n\nReturns the preferred multiple of work-group size for the function specified by Invoke. This is a performance hint. Specifying a work-group size that is not a multiple of the value returned by this query as the value of the local work size will not fail to enqueue Invoke for execution unless the work-group size specified is larger than the device maximum.\n\nResult Type must be a 32-bit integer type scalar.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 296,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Invoke",
        "Type": "ID"
      },
      {
        "Name": "Param",
        "Type": "ID"
      },
      {
        "Name": "ParamSize",
        "Type": "ID"
      },
      {
        "Name": "ParamAlign",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpRetainEvent",
    "Description": "<a id=\"OpRetainEvent\"></a><strong>OpRetainEvent</strong><br />\n<br />\nIncrements the reference count of the event object specified by <em>Event</em>.<br />\n<br />\n<em>Event</em> must be an event that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a>, <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a> or <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.",
    "DescriptionPlain": "OpRetainEvent\n\nIncrements the reference count of the event object specified by Event.\n\nEvent must be an event that was produced by OpEnqueueKernel, OpEnqueueMarker or OpCreateUserEvent.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 297,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Event",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpReleaseEvent",
    "Description": "<a id=\"OpReleaseEvent\"></a><strong>OpReleaseEvent</strong><br />\n<br />\nDecrements the reference count of the event object specified by <em>Event</em>. The event object is deleted once the event reference count is zero, the specific command identified by this event has completed (or terminated) and there are no commands in any device command queue that require a wait for this event to complete.<br />\n<br />\n<em>Event</em> must be an event that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a>, <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a> or <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.",
    "DescriptionPlain": "OpReleaseEvent\n\nDecrements the reference count of the event object specified by Event. The event object is deleted once the event reference count is zero, the specific command identified by this event has completed (or terminated) and there are no commands in any device command queue that require a wait for this event to complete.\n\nEvent must be an event that was produced by OpEnqueueKernel, OpEnqueueMarker or OpCreateUserEvent.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "2",
    "WordCountFix": 2,
    "OpCode": 298,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Event",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpCreateUserEvent",
    "Description": "<a id=\"OpCreateUserEvent\"></a><strong>OpCreateUserEvent</strong><br />\n<br />\nCreate a user event. The execution status of the created event is set to a value of 2 (CL_SUBMITTED).<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.",
    "DescriptionPlain": "OpCreateUserEvent\n\nCreate a user event. The execution status of the created event is set to a value of 2 (CL_SUBMITTED).\n\nResult Type must be OpTypeDeviceEvent.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 299,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIsValidEvent",
    "Description": "<a id=\"OpIsValidEvent\"></a><strong>OpIsValidEvent</strong><br />\n<br />\nReturns <strong>true</strong> if the event specified by <em>Event</em> is a valid event, otherwise result is <strong>false</strong>.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n<em>Event</em> must have a type of <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>",
    "DescriptionPlain": "OpIsValidEvent\n\nReturns true if the event specified by Event is a valid event, otherwise result is false.\n\nResult Type must be a Boolean type.\n\nEvent must have a type of OpTypeDeviceEvent",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 300,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Event",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpSetUserEventStatus",
    "Description": "<a id=\"OpSetUserEventStatus\"></a><strong>OpSetUserEventStatus</strong><br />\n<br />\nSets the execution status of a user event specified by <em>Event</em>.<em>Status</em> can be either 0 (CL_COMPLETE) to indicate that this kernel and all its child kernels finished execution successfully, or a negative integer value indicating an error.<br />\n<br />\n<em>Event</em> must have a type of <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> that was produced by <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.<br />\n<br />\n<em>Status</em> must have a type of 32-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> treated as a signed integer.",
    "DescriptionPlain": "OpSetUserEventStatus\n\nSets the execution status of a user event specified by Event.Status can be either 0 (CL_COMPLETE) to indicate that this kernel and all its child kernels finished execution successfully, or a negative integer value indicating an error.\n\nEvent must have a type of OpTypeDeviceEvent that was produced by OpCreateUserEvent.\n\nStatus must have a type of 32-bit OpTypeInt treated as a signed integer.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 301,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Event",
        "Type": "ID"
      },
      {
        "Name": "Status",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpCaptureEventProfilingInfo",
    "Description": "<a id=\"OpCaptureEventProfilingInfo\"></a><strong>OpCaptureEventProfilingInfo</strong><br />\n<br />\nCaptures the profiling information specified by <em>Profiling Info</em> for the command associated with the event specified by <em>Event</em> in the memory pointed to by <em>Value</em>.The profiling information will be available in the memory pointed to by <em>Value</em> once the command identified by <em>Event</em> has completed.<br />\n<br />\n<em>Event</em> must have a type of <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a> or <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a>. <br />\n<br />\n<em>Profiling Info</em> must be an <a href=\"#Integer\"><em>integer type</em></a> scalar.  The content of <em>Profiling Info</em> is interpreted as <a href=\"#Kernel_Profiling_Info\"><em>Kernel Profiling Info</em></a> mask.<br />\n<br />\n<em>Value</em> must be a pointer to a scalar 8-bit <a href=\"#Integer\"><em>integer type</em></a> in the <strong>CrossWorkgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\nWhen <em>Profiling Info</em> is <strong>CmdExecTime</strong>, <em>Value</em> must point to 128-bit memory range.<br />\n The first 64 bits contain the elapsed time CL_PROFILING_COMMAND_END - CL_PROFILING_COMMAND_START for the command identified by <em>Event</em> in nanoseconds.<br />\n The second 64 bits contain the elapsed time CL_PROFILING_COMMAND_COMPLETE - CL_PROFILING_COMMAND_START for the command identified by <em>Event</em> in nanoseconds.<br />\n<br />\n<strong>Note:</strong> The behavior of this instruction is undefined when called multiple times for the same event.",
    "DescriptionPlain": "OpCaptureEventProfilingInfo\n\nCaptures the profiling information specified by Profiling Info for the command associated with the event specified by Event in the memory pointed to by Value.The profiling information will be available in the memory pointed to by Value once the command identified by Event has completed.\n\nEvent must have a type of OpTypeDeviceEvent that was produced by OpEnqueueKernel or OpEnqueueMarker. \n\nProfiling Info must be an integer type scalar.  The content of Profiling Info is interpreted as Kernel Profiling Info mask.\n\nValue must be a pointer to a scalar 8-bit integer type in the CrossWorkgroup Storage Class.\n\nWhen Profiling Info is CmdExecTime, Value must point to 128-bit memory range.\n The first 64 bits contain the elapsed time CL_PROFILING_COMMAND_END - CL_PROFILING_COMMAND_START for the command identified by Event in nanoseconds.\n The second 64 bits contain the elapsed time CL_PROFILING_COMMAND_COMPLETE - CL_PROFILING_COMMAND_START for the command identified by Event in nanoseconds.\n\nNote: The behavior of this instruction is undefined when called multiple times for the same event.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 302,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Event",
        "Type": "ID"
      },
      {
        "Name": "ProfilingInfo",
        "Type": "ID"
      },
      {
        "Name": "Value",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGetDefaultQueue",
    "Description": "<a id=\"OpGetDefaultQueue\"></a><strong>OpGetDefaultQueue</strong><br />\n<br />\nReturns the default device queue. If a default device queue has not been created, a null queue object is returned.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeQueue\"><strong>OpTypeQueue</strong></a>.",
    "DescriptionPlain": "OpGetDefaultQueue\n\nReturns the default device queue. If a default device queue has not been created, a null queue object is returned.\n\nResult Type must be an OpTypeQueue.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "3",
    "WordCountFix": 3,
    "OpCode": 303,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpBuildNDRange",
    "Description": "<a id=\"OpBuildNDRange\"></a><strong>OpBuildNDRange</strong><br />\n<br />\nGiven the global work size specified by <em>GlobalWorkSize</em>, local work size specified by <em>LocalWorkSize</em> and global work offset specified by <em>GlobalWorkOffset</em>, builds a 1D, 2D or 3D ND-range descriptor structure and returns it.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with the following ordered list of members, starting from the first to last:<br />\n<br />\n   1) 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, that specifies the number of dimensions used to specify the global work-items and work-items in the work-group. <br />\n<br />\n   2) <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical32</strong> and 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical64</strong>. This member is an array of per-dimension unsigned values that describe the offset used to calculate the global ID of a work-item.<br />\n<br />\n   3) <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical32</strong> and 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical64</strong>. This member is an array of per-dimension unsigned values that describe the number of global work-items in the dimensions that will execute the kernel function.<br />\n<br />\n   4) <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical32</strong> and 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical64</strong>. This member is an array of per-dimension unsigned values that describe the number of work-items that make up a work-group.<br />\n<br />\n<em>GlobalWorkSize</em> must be a scalar or an array with 2 or 3 components. Where the type of each element in the array is 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical32</strong> or 64-bit <a href=\"#Integer\"><em>integer type</em></a> scalar when the <a href=\"#Addressing_Model\"><em>addressing model</em></a> is <strong>Physical64</strong>.<br />\n<br />\nThe type of <em>LocalWorkSize</em> must be the same as <em>GlobalWorkSize</em>.<br />\n<br />\nThe type of <em>GlobalWorkOffset</em> must be the same as <em>GlobalWorkSize</em>.",
    "DescriptionPlain": "OpBuildNDRange\n\nGiven the global work size specified by GlobalWorkSize, local work size specified by LocalWorkSize and global work offset specified by GlobalWorkOffset, builds a 1D, 2D or 3D ND-range descriptor structure and returns it.\n\nResult Type must be an OpTypeStruct with the following ordered list of members, starting from the first to last:\n\n   1) 32-bit integer type scalar, that specifies the number of dimensions used to specify the global work-items and work-items in the work-group. \n\n   2) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar when the addressing model is Physical32 and 64-bit integer type scalar when the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the offset used to calculate the global ID of a work-item.\n\n   3) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar when the addressing model is Physical32 and 64-bit integer type scalar when the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the number of global work-items in the dimensions that will execute the kernel function.\n\n   4) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar when the addressing model is Physical32 and 64-bit integer type scalar when the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the number of work-items that make up a work-group.\n\nGlobalWorkSize must be a scalar or an array with 2 or 3 components. Where the type of each element in the array is 32-bit integer type scalar when the addressing model is Physical32 or 64-bit integer type scalar when the addressing model is Physical64.\n\nThe type of LocalWorkSize must be the same as GlobalWorkSize.\n\nThe type of GlobalWorkOffset must be the same as GlobalWorkSize.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 304,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "GlobalWorkSize",
        "Type": "ID"
      },
      {
        "Name": "LocalWorkSize",
        "Type": "ID"
      },
      {
        "Name": "GlobalWorkOffset",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGetKernelLocalSizeForSubgroupCount",
    "Description": "<a id=\"OpGetKernelLocalSizeForSubgroupCount\"></a><strong>OpGetKernelLocalSizeForSubgroupCount</strong><br />\n<br />\nReturns the 1D local size to enqueue <em>Invoke</em> with <em>Subgroup Count</em> subgroups per workgroup.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Subgroup Count</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
    "DescriptionPlain": "OpGetKernelLocalSizeForSubgroupCount\n\nReturns the 1D local size to enqueue Invoke with Subgroup Count subgroups per workgroup.\n\nResult Type must be a 32-bit integer type scalar.\n\nSubgroup Count must be a 32-bit integer type scalar.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8",
    "WordCountFix": 8,
    "OpCode": 325,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "SubgroupCount",
        "Type": "ID"
      },
      {
        "Name": "Invoke",
        "Type": "ID"
      },
      {
        "Name": "Param",
        "Type": "ID"
      },
      {
        "Name": "ParamSize",
        "Type": "ID"
      },
      {
        "Name": "ParamAlign",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGetKernelMaxNumSubgroups",
    "Description": "<a id=\"OpGetKernelMaxNumSubgroups\"></a><strong>OpGetKernelMaxNumSubgroups</strong><br />\n<br />\nReturns the maximum number of subgroups that can be used to execute <em>Invoke</em> on the devce.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Invoke</em> must be an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> whose <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> operand has:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to an 8-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- An optional list of parameters, each of which must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to the <strong>Workgroup</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be a pointer to an 8-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed to by <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em> and must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned integer.",
    "DescriptionPlain": "OpGetKernelMaxNumSubgroups\n\nReturns the maximum number of subgroups that can be used to execute Invoke on the devce.\n\nResult Type must be a 32-bit integer type scalar.\n\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\n\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\n\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\n\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
    "Category": "Device-SideEnqueue",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 326,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Invoke",
        "Type": "ID"
      },
      {
        "Name": "Param",
        "Type": "ID"
      },
      {
        "Name": "ParamSize",
        "Type": "ID"
      },
      {
        "Name": "ParamAlign",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpReadPipe",
    "Description": "<a id=\"OpReadPipe\"></a><strong>OpReadPipe</strong><br />\n<br />\nRead a packet from the pipe object specified by <em>Pipe</em> into <em>Pointer</em>. Result is 0 if the operation is successful and a negative value if the pipe is empty.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>Pipe</em> and a <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpReadPipe\n\nRead a packet from the pipe object specified by Pipe into Pointer. Result is 0 if the operation is successful and a negative value if the pipe is empty.\n\nResult Type must be a 32-bit integer type scalar.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 274,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpWritePipe",
    "Description": "<a id=\"OpWritePipe\"></a><strong>OpWritePipe</strong><br />\n<br />\nWrite a packet from <em>Pointer</em> to the pipe object specified by <em>Pipe</em>. Result is 0 if the operation is successful and a negative value if the pipe is full.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>Pipe</em> and a <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpWritePipe\n\nWrite a packet from Pointer to the pipe object specified by Pipe. Result is 0 if the operation is successful and a negative value if the pipe is full.\n\nResult Type must be a 32-bit integer type scalar.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 275,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpReservedReadPipe",
    "Description": "<a id=\"OpReservedReadPipe\"></a><strong>OpReservedReadPipe</strong><br />\n<br />\nRead a packet from the reserved area specified by <em>Reserve Id</em> and <em>Index</em> of the pipe object specified by <em>Pipe</em> into <em>Pointer</em>. The reserved pipe entries are referred to by indices that go from 0 &#8230; <em>Num Packets</em> - 1. Result is 0 if the operation is successful and a negative value otherwise.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Index</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>Pipe</em> and a <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpReservedReadPipe\n\nRead a packet from the reserved area specified by Reserve Id and Index of the pipe object specified by Pipe into Pointer. The reserved pipe entries are referred to by indices that go from 0 &#8230; Num Packets - 1. Result is 0 if the operation is successful and a negative value otherwise.\n\nResult Type must be a 32-bit integer type scalar.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nIndex must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "9",
    "WordCountFix": 9,
    "OpCode": 276,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "ReserveId",
        "Type": "ID"
      },
      {
        "Name": "Index",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpReservedWritePipe",
    "Description": "<a id=\"OpReservedWritePipe\"></a><strong>OpReservedWritePipe</strong><br />\n<br />\nWrite a packet from <em>Pointer</em> into the reserved area specified by <em>Reserve Id</em> and <em>Index</em> of the pipe object specified by <em>Pipe</em>. The reserved pipe entries are referred to by indices that go from 0 &#8230; <em>Num Packets</em> - 1. Result is 0 if the operation is successful and a negative value otherwise.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Index</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Pointer</em> must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>Pipe</em> and a <strong>Generic</strong> <a href=\"#Storage_Class\">Storage Class</a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpReservedWritePipe\n\nWrite a packet from Pointer into the reserved area specified by Reserve Id and Index of the pipe object specified by Pipe. The reserved pipe entries are referred to by indices that go from 0 &#8230; Num Packets - 1. Result is 0 if the operation is successful and a negative value otherwise.\n\nResult Type must be a 32-bit integer type scalar.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nIndex must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "9",
    "WordCountFix": 9,
    "OpCode": 277,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "ReserveId",
        "Type": "ID"
      },
      {
        "Name": "Index",
        "Type": "ID"
      },
      {
        "Name": "Pointer",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpReserveReadPipePackets",
    "Description": "<a id=\"OpReserveReadPipePackets\"></a><strong>OpReserveReadPipePackets</strong><br />\n<br />\nReserve <em>Num Packets</em> entries for reading from the pipe object specified by <em>Pipe</em>. Result is a valid reservation ID if the reservation is successful.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Num Packets</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpReserveReadPipePackets\n\nReserve Num Packets entries for reading from the pipe object specified by Pipe. Result is a valid reservation ID if the reservation is successful.\n\nResult Type must be an OpTypeReserveId.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 278,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "NumPackets",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpReserveWritePipePackets",
    "Description": "<a id=\"OpReserveWritePipePackets\"></a><strong>OpReserveWritePipePackets</strong><br />\n<br />\nReserve <em>num_packets</em> entries for writing to the pipe object specified by <em>Pipe</em>. Result is a valid reservation ID if the reservation is successful.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Num Packets</em> must be a 32-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> which is treated as an unsigned value.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpReserveWritePipePackets\n\nReserve num_packets entries for writing to the pipe object specified by Pipe. Result is a valid reservation ID if the reservation is successful.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nNum Packets must be a 32-bit OpTypeInt which is treated as an unsigned value.\n\nResult Type must be an OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "7",
    "WordCountFix": 7,
    "OpCode": 279,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "NumPackets",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpCommitReadPipe",
    "Description": "<a id=\"OpCommitReadPipe\"></a><strong>OpCommitReadPipe</strong><br />\n<br />\nIndicates that all reads to <em>Num Packets</em> associated with the reservation specified by <em>Reserve Id</em> and the pipe object specified by <em>Pipe</em> are completed.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpCommitReadPipe\n\nIndicates that all reads to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe are completed.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 280,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "ReserveId",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpCommitWritePipe",
    "Description": "<a id=\"OpCommitWritePipe\"></a><strong>OpCommitWritePipe</strong><br />\n<br />\nIndicates that all writes to <em>Num Packets</em> associated with the reservation specified by <em>Reserve Id</em> and the pipe object specified by <em>Pipe</em> are completed.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpCommitWritePipe\n\nIndicates that all writes to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe are completed.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "5",
    "WordCountFix": 5,
    "OpCode": 281,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "ReserveId",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpIsValidReserveId",
    "Description": "<a id=\"OpIsValidReserveId\"></a><strong>OpIsValidReserveId</strong><br />\n<br />\nReturn <strong>true</strong> if <em>Reserve Id</em> is a valid reservation id and <strong>false</strong> otherwise.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.",
    "DescriptionPlain": "OpIsValidReserveId\n\nReturn true if Reserve Id is a valid reservation id and false otherwise.\n\nResult Type must be a Boolean type.\n\nReserve Id must have a type of OpTypeReserveId.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 282,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ReserveId",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGetNumPipePackets",
    "Description": "<a id=\"OpGetNumPipePackets\"></a><strong>OpGetNumPipePackets</strong><br />\n<br />\nResult is the number of available entries in the pipe object specified by <em>Pipe</em>. The number of available entries in a pipe is a dynamic value.  The value returned should be considered immediately stale.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which should be treated as an unsigned value.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> or <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpGetNumPipePackets\n\nResult is the number of available entries in the pipe object specified by Pipe. The number of available entries in a pipe is a dynamic value.  The value returned should be considered immediately stale.\n\nResult Type must be a 32-bit integer type scalar, which should be treated as an unsigned value.\n\nPipe must have a type of OpTypePipe with ReadOnly or WriteOnly access qualifier.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 283,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGetMaxPipePackets",
    "Description": "<a id=\"OpGetMaxPipePackets\"></a><strong>OpGetMaxPipePackets</strong><br />\n<br />\nResult is the maximum number of packets specified when the pipe object specified by <em>Pipe</em> was created.<br />\n<br />\n<em>Result Type</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which should be treated as an unsigned value.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> or <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpGetMaxPipePackets\n\nResult is the maximum number of packets specified when the pipe object specified by Pipe was created.\n\nResult Type must be a 32-bit integer type scalar, which should be treated as an unsigned value.\n\nPipe must have a type of OpTypePipe with ReadOnly or WriteOnly access qualifier.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 284,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupReserveReadPipePackets",
    "Description": "<a id=\"OpGroupReserveReadPipePackets\"></a><strong>OpGroupReserveReadPipePackets</strong><br />\n<br />\nReserve <em>Num Packets</em> entries for reading from the pipe object specified by <em>Pipe</em> at group level. Result is a valid reservation id if the reservation is successful.<br />\n<br />\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; <em>Num Packets</em> - 1.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Num Packets</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpGroupReserveReadPipePackets\n\nReserve Num Packets entries for reading from the pipe object specified by Pipe at group level. Result is a valid reservation id if the reservation is successful.\n\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; Num Packets - 1.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be an OpTypeReserveId.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8",
    "WordCountFix": 8,
    "OpCode": 285,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "NumPackets",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupReserveWritePipePackets",
    "Description": "<a id=\"OpGroupReserveWritePipePackets\"></a><strong>OpGroupReserveWritePipePackets</strong><br />\n<br />\nReserve <em>Num Packets</em> entries for writing to the pipe object specified by <em>Pipe</em> at group level. Result is a valid reservation ID if the reservation is successful.<br />\n<br />\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; <em>Num Packets</em> - 1.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Num Packets</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar, which is treated as an unsigned value.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpGroupReserveWritePipePackets\n\nReserve Num Packets entries for writing to the pipe object specified by Pipe at group level. Result is a valid reservation ID if the reservation is successful.\n\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; Num Packets - 1.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nResult Type must be an OpTypeReserveId.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "8",
    "WordCountFix": 8,
    "OpCode": 286,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "NumPackets",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupCommitReadPipe",
    "Description": "<a id=\"OpGroupCommitReadPipe\"></a><strong>OpGroupCommitReadPipe</strong><br />\n<br />\nA group level indication that all reads to <em>Num Packets</em> associated with the reservation specified by <em>Reserve Id</em> to the pipe object specified by <em>Pipe</em> are completed.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpGroupCommitReadPipe\n\nA group level indication that all reads to Num Packets associated with the reservation specified by Reserve Id to the pipe object specified by Pipe are completed.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 287,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "ReserveId",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpGroupCommitWritePipe",
    "Description": "<a id=\"OpGroupCommitWritePipe\"></a><strong>OpGroupCommitWritePipe</strong><br />\n<br />\nA group level indication that all writes to <em>Num Packets</em> associated with the reservation specified by <em>Reserve Id</em> to the pipe object specified by <em>Pipe</em> are completed.<br />\n<br />\nAll <a href=\"#Invocation\">invocations</a> of this module within <em>Execution</em> must reach this point of execution.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within <a href=\"#UniformControlFlow\">uniform control flow</a> within <em>Execution</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\n<em>Execution</em> must be <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Scope_-id-\"><em>Scope</em></a>.<br />\n<br />\n<em>Pipe</em> must have a type of <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access_Qualifier\"><em>access qualifier</em></a>.<br />\n<br />\n<em>Reserve Id</em> must have a type of <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.",
    "DescriptionPlain": "OpGroupCommitWritePipe\n\nA group level indication that all writes to Num Packets associated with the reservation specified by Reserve Id to the pipe object specified by Pipe are completed.\n\nAll invocations of this module within Execution must reach this point of execution.\n\nThis instruction is only guaranteed to work correctly if placed strictly within uniform control flow within Execution. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nExecution must be Workgroup or Subgroup Scope.\n\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\n\nReserve Id must have a type of OpTypeReserveId.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 288,
    "HasVariableWordCount": false,
    "HasResult": false,
    "HasResultType": false,
    "Operands": [
      {
        "Name": "ScopeExecution",
        "Type": "ID"
      },
      {
        "Name": "Pipe",
        "Type": "ID"
      },
      {
        "Name": "ReserveId",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "ID"
      },
      {
        "Name": "PacketAlignment",
        "Type": "ID"
      }
    ]
  },
  {
    "Name": "OpConstantPipeStorage",
    "Description": "<a id=\"OpConstantPipeStorage\"></a><strong>OpConstantPipeStorage</strong><br />\n<br />\nCreates a pipe-storage object.<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypePipeStorage\"><strong>OpTypePipeStorage</strong></a>.<br />\n<br />\n<em>Packet Size</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that represents the size in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Alignment</em> must be a 32-bit <a href=\"#Integer\"><em>integer type</em></a> scalar that presents the alignment in bytes of each packet in the pipe.<br />\n<br />\n<em>Packet Size</em> and <em>Packet Alignment</em> must satisfy the following: <br />\n - 1 &lt;= <em>Packet Alignment</em> &lt;= <em>Packet Size</em>. <br />\n - <em>Packet Alignment</em> must evenly divide <em>Packet Size</em><br />\n<br />\nFor concrete types, <em>Packet Alignment</em> should equal <em>Packet Size</em>.  For aggregate types, <em>Packet Alignment</em> should be the size of the largest primitive type in the hierarchy of types.<br />\n<br />\n<em>Capacity</em> is the minimum number of <em>Packet Size</em> blocks the resulting <a href=\"#OpTypePipeStorage\"><strong>OpTypePipeStorage</strong></a> can hold.",
    "DescriptionPlain": "OpConstantPipeStorage\n\nCreates a pipe-storage object.\n\nResult Type must be OpTypePipeStorage.\n\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\n\nPacket Alignment must be a 32-bit integer type scalar that presents the alignment in bytes of each packet in the pipe.\n\nPacket Size and Packet Alignment must satisfy the following: \n - 1 &lt;= Packet Alignment &lt;= Packet Size. \n - Packet Alignment must evenly divide Packet Size\n\nFor concrete types, Packet Alignment should equal Packet Size.  For aggregate types, Packet Alignment should be the size of the largest primitive type in the hierarchy of types.\n\nCapacity is the minimum number of Packet Size blocks the resulting OpTypePipeStorage can hold.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "6",
    "WordCountFix": 6,
    "OpCode": 323,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "PacketSize",
        "Type": "LiteralNumber"
      },
      {
        "Name": "PacketAlignment",
        "Type": "LiteralNumber"
      },
      {
        "Name": "Capacity",
        "Type": "LiteralNumber"
      }
    ]
  },
  {
    "Name": "OpCreatePipeFromPipeStorage",
    "Description": "<a id=\"OpCreatePipeFromPipeStorage\"></a><strong>OpCreatePipeFromPipeStorage</strong><br />\n<br />\nCreates a pipe object from a pipe-storage object.<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a>.<br />\n<br />\n<em>Pipe Storage</em> must be a pipe-storage object created from <a href=\"#OpConstantPipeStorage\"><strong>OpConstantPipeStorage</strong></a>.<br />\n<br />\n<em>Qualifier</em> is the pipe access qualifier.",
    "DescriptionPlain": "OpCreatePipeFromPipeStorage\n\nCreates a pipe object from a pipe-storage object.\n\nResult Type must be OpTypePipe.\n\nPipe Storage must be a pipe-storage object created from OpConstantPipeStorage.\n\nQualifier is the pipe access qualifier.",
    "Category": "Pipe",
    "Capabilities": [
      "Capability"
    ],
    "WordCount": "4",
    "WordCountFix": 4,
    "OpCode": 324,
    "HasVariableWordCount": false,
    "HasResult": true,
    "HasResultType": true,
    "Operands": [
      {
        "Name": "ResultType",
        "Type": "ID"
      },
      {
        "Name": "Result",
        "Type": "ID"
      },
      {
        "Name": "PipeStorage",
        "Type": "ID"
      }
    ]
  }
]