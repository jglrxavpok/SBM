// Auto-generated from org.jglr.sbm.generation.SPIRVMemoryVisitorGenerator
package org.jglr.sbm.visitors;

import org.jglr.sbm.FunctionControl;
import org.jglr.sbm.AddressingModel;
import org.jglr.sbm.MemoryModel;
import org.jglr.sbm.ExecutionModel;
import org.jglr.sbm.ExecutionMode;
import org.jglr.sbm.Capability;
import org.jglr.sbm.StorageClass;
import org.jglr.sbm.MemoryAccess;

/**
Autogenerated from spirv-opcodesonly.json
*/

public interface MemoryVisitor {
    
    
    
    /**
    OpMemoryModel
    <br/>
    <br/>Set addressing model and memory model for the entire module.
    <br/>
    <br/>Addressing Model selects the module&#8217;s Addressing Model.
    <br/>
    <br/>Memory Model selects the module&#8217;s memory model, see Memory Model.
    */
    void visitMemoryModel(AddressingModel addressingModel, MemoryModel memoryModel);
    
    
    /**
    OpEntryPoint
    <br/>
    <br/>Declare an entry point and its execution model.
    <br/>
    <br/>Execution Model is the execution model for the entry point and its static call tree.  See Execution Model.
    <br/>
    <br/>Entry Point must be the Result &lt;id&gt; of an OpFunction instruction.
    <br/>
    <br/>Name is a name string for the entry point. A module cannot have two OpEntryPoint instructions with the same Execution Model and the same Name string.
    <br/>
    <br/>Interface is a list of &lt;id&gt; of global OpVariable instructions with either Input or Output for its Storage Class operand. These declare the input/output interface of the entry point.  They could be a subset of the input/output declarations of the module, and a superset of those referenced by the entry point&#8217;s static call tree. It is invalid for the entry point&#8217;s static call tree to reference such an &lt;id&gt; if it was not listed with this instruction.
    <br/>
    <br/>Interface &lt;id&gt; are forward references.  They allow declaration of all variables forming an interface for an entry point, whether or not all the variables are actually used by the entry point.
    */
    void visitEntryPoint(ExecutionModel executionModel, long entryPoint, String name, long[] interfaces);
    
    
    /**
    OpExecutionMode
    <br/>
    <br/>Declare an execution mode for an entry point.
    <br/>
    <br/>Entry Point must be the Entry Point &lt;id&gt; operand of an OpEntryPoint instruction.
    <br/>
    <br/>Mode is the execution mode. See Execution Mode.
    */
    void visitExecutionMode(long entryPoint, ExecutionMode mode);
    
    
    /**
    OpCapability
    <br/>
    <br/>Declare a capability used by this module.
    <br/>
    <br/>Capability is the capability declared by this instruction.  There are no restrictions on the order in which capabilities are declared.
    <br/>
    <br/>See the capabilities section for more detail.
    */
    void visitCapability(Capability capability);
    
    
    /**
    OpVariable
    <br/>
    <br/>Allocate an object in memory, resulting in a pointer to it, which can be used with OpLoad and OpStore.
    <br/>
    <br/> Result Type must be an OpTypePointer. Its Type operand is the type of object in memory.
    <br/>
    <br/>Storage Class is the Storage Class of the memory holding the object. It cannot be Generic.
    <br/>
    <br/>Initializer is optional.  If Initializer is present, it will be the initial value of the variable&#8217;s memory content. Initializer must be an &lt;id&gt; from a constant instruction or a global (module scope) OpVariable instruction. Initializer must have the same type as the type pointed to by Result Type.
    */
    void visitVariable(long resultType, long result, StorageClass storageClass, long optionalLong);
    
    
    /**
    OpImageTexelPointer
    <br/>
    <br/>Form a pointer to a texel of an image. Use of such a pointer is limited to atomic operations.
    <br/>
    <br/>Result Type must be an OpTypePointer whose Storage Class operand is Image. Its Type operand must be a scalar numerical type or OpTypeVoid.
    <br/>
    <br/>Image must have a type of OpTypePointer with Type OpTypeImage. The Sampled Type of the type of Image must be the same as the Type pointed to by Result Type. The Dim operand of Type cannot be SubpassData.
    <br/>
    <br/>Coordinate and Sample specify which texel and sample within the image to form a pointer to.
    <br/>
    <br/>Coordinate must be a scalar or vector of integer type.  It must have the number of components specified below, given the following Arrayed and Dim operands of the type of the OpTypeImage.
    <br/>
    <br/>If Arrayed is 0:
    <br/>1D: scalar
    <br/>2D: 2 components
    <br/>3D: 3 components
    <br/>Cube: 3 components
    <br/>Rect: 2 components
    <br/>Buffer: scalar
    <br/>
    <br/>If Arrayed is 1:
    <br/>1D: 2 components
    <br/>2D: 3 components
    <br/>Cube: 4 components
    <br/>
    <br/>Sample must be an integer type scalar. It specifies which sample to select at the given coordinate.  It must be a valid &lt;id&gt; for the value 0 if the OpTypeImage has MS of 0.
    */
    void visitImageTexelPointer(long resultType, long result, long image, long coordinate, long sample);
    
    
    /**
    OpLoad
    <br/>
    <br/>Load through a pointer.
    <br/>
    <br/>Result Type is the type of the loaded object.
    <br/>
    <br/>Pointer is the pointer to load through.  Its type must be an OpTypePointer whose Type operand is the same as Result Type.
    <br/>
    <br/>Memory Access must be a Memory Access literal. If not present, it is the same as specifying None.
    */
    void visitLoad(long resultType, long result, long pointer, MemoryAccess optionalMemoryAccess);
    
    
    /**
    OpStore
    <br/>
    <br/>Store through a pointer.
    <br/>
    <br/>Pointer is the pointer to store through.  Its type must be an OpTypePointer whose Type operand is the same as the type of Object.
    <br/>
    <br/>Object is the object to store.
    <br/>
    <br/>Memory Access must be a Memory Access literal. If not present, it is the same as specifying None.
    */
    void visitStore(long pointer, long object, MemoryAccess optionalMemoryAccess);
    
    
    /**
    OpCopyMemory
    <br/>
    <br/>Copy from the memory pointed to by Source to the memory pointed to by Target. Both operands must be non-void pointers of the same type.  Matching Storage Class is not required. The amount of memory copied is the size of the type pointed to.
    <br/>
    <br/>Memory Access must be a Memory Access literal. If not present, it is the same as specifying None.
    */
    void visitCopyMemory(long target, long source, MemoryAccess optionalMemoryAccess);
    
    
    /**
    OpCopyMemorySized
    <br/>
    <br/>Copy from the memory pointed to by Source to the memory pointed to by Target. 
    <br/>
    <br/>Size is the number of bytes to copy. It must have a scalar integer type. If it is a constant instruction, the constant value cannot be 0. It is invalid for both the constant&#8217;s type to have Signedness of 1 and to have the sign bit set. Otherwise, as a run-time value, Size is treated as unsigned, and if its value is 0, no memory access will be made.
    <br/>
    <br/>Memory Access must be a Memory Access literal. If not present, it is the same as specifying None.
    */
    void visitCopyMemorySized(long target, long source, long size, MemoryAccess optionalMemoryAccess);
    
    
    /**
    OpAccessChain
    <br/>
    <br/>Create a pointer into a composite object that can be used with OpLoad and OpStore. 
    <br/>
    <br/> Result Type must be an OpTypePointer. Its Type operand must be the type reached by walking the Base&#8217;s type hierarchy down to the last provided index in Indexes, and its Storage Class operand must be the same as the Storage Class of Base.
    <br/>
    <br/>Base must be a pointer, pointing to the base of a composite object.
    <br/>
    <br/>Indexes walk the type hierarchy to the desired depth, potentially down to scalar granularity. The first index in Indexes will select the top-level member/element/component/element of the base composite. All composite constituents use zero-based numbering, as described by their OpType&#8230; instruction. The second index will apply similarly to that result, and so on. Once any non-composite type is reached, there must be no remaining (unused) indexes. Each of the Indexes must:
    <br/>- be a scalar integer type,
    <br/>- be an OpConstant when indexing into a structure.
    */
    void visitAccessChain(long resultType, long result, long base, long[] indexes);
    
    
    /**
    OpInBoundsAccessChain
    <br/>
    <br/>Has the same semantics as OpAccessChain, with the addition that the resulting pointer is known to point within the base object.
    */
    void visitInBoundsAccessChain(long resultType, long result, long base, long[] indexes);
    
    
    /**
    OpPtrAccessChain
    <br/>
    <br/>Has the same semantics as OpAccessChain, with the addition of the Element operand.
    <br/>
    <br/>Element is used to do the initial dereference of Base: Base is treated as the address of the first element of an array, and the Element element&#8217;s address is computed to be the base for the Indexes, as per OpAccessChain. The type of Base after being dereferenced with Element is still the same as the original type of Base.
    <br/>
    <br/>Note: If Base is originally typed to be a pointer an array, and the desired operation is to select an element of that array, OpAccessChain should be directly used, as its first Index will select the array element.
    */
    void visitPtrAccessChain(long resultType, long result, long base, long element, long[] indexes);
    
    
    /**
    OpArrayLength
    <br/>
    <br/>Length of a run-time array.
    <br/>
    <br/>Result Type must be an OpTypeInt with 32-bit Width and 0 Signedness.
    <br/>
    <br/>Structure must have a type of OpTypeStruct whose last member is a run-time array.
    <br/>
    <br/>Array member is the last member number of Structure and must have a type from OpTypeRuntimeArray.
    */
    void visitArrayLength(long resultType, long result, long structure, long member);
    
    
    /**
    OpGenericPtrMemSemantics
    <br/>
    <br/>Result is a valid Memory Semantics which includes mask bits set for the Storage Class for the specific (non-Generic) Storage Class of Pointer. 
    <br/>
    <br/>Pointer must point to Generic Storage Class.
    <br/>
    <br/>Result Type must be an OpTypeInt with 32-bit Width and 0 Signedness.
    */
    void visitGenericPtrMemSemantics(long resultType, long result, long pointer);
    
    
    /**
    OpInBoundsPtrAccessChain
    <br/>
    <br/>Has the same semantics as OpPtrAccessChain, with the addition that the resulting pointer is known to point within the base object.
    */
    void visitInBoundsPtrAccessChain(long resultType, long result, long base, long element, long[] indexes);
    
}
