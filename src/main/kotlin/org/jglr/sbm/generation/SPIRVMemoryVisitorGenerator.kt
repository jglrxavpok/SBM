package org.jglr.sbm.generation

object SPIRVMemoryVisitorGenerator : VisitorGenerator() {
    override val packageName: String? = "org.jglr.sbm.visitors"
    override val imports: List<String> = listOf("org.jglr.sbm.FunctionControl", "org.jglr.sbm.AddressingModel",
            "org.jglr.sbm.MemoryModel", "org.jglr.sbm.ExecutionModel", "org.jglr.sbm.ExecutionMode",
            "org.jglr.sbm.Capability", "org.jglr.sbm.StorageClass", "org.jglr.sbm.MemoryAccess")
    override val headerDoc: String? = "Autogenerated from spirv-opcodesonly.json"

    override fun fillMemberList(members: MutableList<ClassMember>) {

    }

    override fun fillFunctionList(members: MutableList<ClassFunction>) {
        SPIRVOpcodes.forEach { op ->
            if(op["Category"] != "Memory" && op["Category"] != "Mode-Setting") {
                return@forEach
            }
            val opname = op["Name"] as String
            if(opname == "OpExecutionMode") {
                val function = ClassFunction("visitExecutionMode", "void", listOf("entryPoint", "mode"), listOf("long", "ExecutionMode"), "")
                function.documentation = op["DescriptionPlain"] as String?
                function.documentation?.let { function.documentation = function.documentation?.replace("\n", "\n<br/>") }
                function.bodyless = true
                members.add(function)
            } else {
                val functionName = "visit${opname.substring(2)}"
                val function = createVisitFunction(opname, functionName, op)
                members.add(function)
            }
        }
    }

    override val title: String = "MemoryVisitor"

    override val type: ClassType = ClassType.INTERFACE
}